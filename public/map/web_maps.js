/*! DO NOT EDIT THIS FILE. It is dynamically created by combining other files: */
/*idxv3/public/js/lib/leaflet/leaflet.markercluster.js,idxv3/public/js/lib/leaflet/leaflet.control.locate.js,idxv3/public/js/lib/leaflet/leaflet.draw.js,idxv3/public/js/lib/leaflet/leaflet.control.searchbymap.js,idxv3/public/js/lib/leaflet/ih-leaflet.js
 */

! function(a, b) { "object" == typeof exports && "undefined" != typeof module ? b(exports) : "function" == typeof define && define.amd ? define(["exports"], b) : b((a.Leaflet = a.Leaflet || {}, a.Leaflet.markercluster = a.Leaflet.markercluster || {})) }(this, function(a) {
    "use strict";
    var b = L.MarkerClusterGroup = L.FeatureGroup.extend({ options: { maxClusterRadius: 80, iconCreateFunction: null, clusterPane: L.Marker.prototype.options.pane, spiderfyOnMaxZoom: !0, showCoverageOnHover: !0, zoomToBoundsOnClick: !0, singleMarkerMode: !1, disableClusteringAtZoom: null, removeOutsideVisibleBounds: !0, animate: !0, animateAddingMarkers: !1, spiderfyDistanceMultiplier: 1, spiderLegPolylineOptions: { weight: 1.5, color: "#222", opacity: .5 }, chunkedLoading: !1, chunkInterval: 200, chunkDelay: 50, chunkProgress: null, polygonOptions: {} }, initialize: function(a) { L.Util.setOptions(this, a), this.options.iconCreateFunction || (this.options.iconCreateFunction = this._defaultIconCreateFunction), this._featureGroup = L.featureGroup(), this._featureGroup.addEventParent(this), this._nonPointGroup = L.featureGroup(), this._nonPointGroup.addEventParent(this), this._inZoomAnimation = 0, this._needsClustering = [], this._needsRemoving = [], this._currentShownBounds = null, this._queue = [], this._childMarkerEventHandlers = { dragstart: this._childMarkerDragStart, move: this._childMarkerMoved, dragend: this._childMarkerDragEnd }; var b = L.DomUtil.TRANSITION && this.options.animate;
            L.extend(this, b ? this._withAnimation : this._noAnimation), this._markerCluster = b ? L.MarkerCluster : L.MarkerClusterNonAnimated }, addLayer: function(a) { if (a instanceof L.LayerGroup) return this.addLayers([a]); if (!a.getLatLng) return this._nonPointGroup.addLayer(a), this.fire("layeradd", { layer: a }), this; if (!this._map) return this._needsClustering.push(a), this.fire("layeradd", { layer: a }), this; if (this.hasLayer(a)) return this;
            this._unspiderfy && this._unspiderfy(), this._addLayer(a, this._maxZoom), this.fire("layeradd", { layer: a }), this._topClusterLevel._recalculateBounds(), this._refreshClustersIcons(); var b = a,
                c = this._zoom; if (a.__parent)
                for (; b.__parent._zoom >= c;) b = b.__parent; return this._currentShownBounds.contains(b.getLatLng()) && (this.options.animateAddingMarkers ? this._animationAddLayer(a, b) : this._animationAddLayerNonAnimated(a, b)), this }, removeLayer: function(a) { return a instanceof L.LayerGroup ? this.removeLayers([a]) : a.getLatLng ? this._map ? a.__parent ? (this._unspiderfy && (this._unspiderfy(), this._unspiderfyLayer(a)), this._removeLayer(a, !0), this.fire("layerremove", { layer: a }), this._topClusterLevel._recalculateBounds(), this._refreshClustersIcons(), a.off(this._childMarkerEventHandlers, this), this._featureGroup.hasLayer(a) && (this._featureGroup.removeLayer(a), a.clusterShow && a.clusterShow()), this) : this : (!this._arraySplice(this._needsClustering, a) && this.hasLayer(a) && this._needsRemoving.push({ layer: a, latlng: a._latlng }), this.fire("layerremove", { layer: a }), this) : (this._nonPointGroup.removeLayer(a), this.fire("layerremove", { layer: a }), this) }, addLayers: function(a, b) { if (!L.Util.isArray(a)) return this.addLayer(a); var c, d = this._featureGroup,
                e = this._nonPointGroup,
                f = this.options.chunkedLoading,
                g = this.options.chunkInterval,
                h = this.options.chunkProgress,
                i = a.length,
                j = 0,
                k = !0; if (this._map) { var l = (new Date).getTime(),
                    m = L.bind(function() { for (var n = (new Date).getTime(); i > j; j++) { if (f && 0 === j % 200) { var o = (new Date).getTime() - n; if (o > g) break } if (c = a[j], c instanceof L.LayerGroup) k && (a = a.slice(), k = !1), this._extractNonGroupLayers(c, a), i = a.length;
                            else if (c.getLatLng) { if (!this.hasLayer(c) && (this._addLayer(c, this._maxZoom), b || this.fire("layeradd", { layer: c }), c.__parent && 2 === c.__parent.getChildCount())) { var p = c.__parent.getAllChildMarkers(),
                                        q = p[0] === c ? p[1] : p[0];
                                    d.removeLayer(q) } } else e.addLayer(c), b || this.fire("layeradd", { layer: c }) } h && h(j, i, (new Date).getTime() - l), j === i ? (this._topClusterLevel._recalculateBounds(), this._refreshClustersIcons(), this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds)) : setTimeout(m, this.options.chunkDelay) }, this);
                m() } else
                for (var n = this._needsClustering; i > j; j++) c = a[j], c instanceof L.LayerGroup ? (k && (a = a.slice(), k = !1), this._extractNonGroupLayers(c, a), i = a.length) : c.getLatLng ? this.hasLayer(c) || n.push(c) : e.addLayer(c); return this }, removeLayers: function(a) { var b, c, d = a.length,
                e = this._featureGroup,
                f = this._nonPointGroup,
                g = !0; if (!this._map) { for (b = 0; d > b; b++) c = a[b], c instanceof L.LayerGroup ? (g && (a = a.slice(), g = !1), this._extractNonGroupLayers(c, a), d = a.length) : (this._arraySplice(this._needsClustering, c), f.removeLayer(c), this.hasLayer(c) && this._needsRemoving.push({ layer: c, latlng: c._latlng }), this.fire("layerremove", { layer: c })); return this } if (this._unspiderfy) { this._unspiderfy(); var h = a.slice(),
                    i = d; for (b = 0; i > b; b++) c = h[b], c instanceof L.LayerGroup ? (this._extractNonGroupLayers(c, h), i = h.length) : this._unspiderfyLayer(c) } for (b = 0; d > b; b++) c = a[b], c instanceof L.LayerGroup ? (g && (a = a.slice(), g = !1), this._extractNonGroupLayers(c, a), d = a.length) : c.__parent ? (this._removeLayer(c, !0, !0), this.fire("layerremove", { layer: c }), e.hasLayer(c) && (e.removeLayer(c), c.clusterShow && c.clusterShow())) : (f.removeLayer(c), this.fire("layerremove", { layer: c })); return this._topClusterLevel._recalculateBounds(), this._refreshClustersIcons(), this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds), this }, clearLayers: function() { return this._map || (this._needsClustering = [], this._needsRemoving = [], delete this._gridClusters, delete this._gridUnclustered), this._noanimationUnspiderfy && this._noanimationUnspiderfy(), this._featureGroup.clearLayers(), this._nonPointGroup.clearLayers(), this.eachLayer(function(a) { a.off(this._childMarkerEventHandlers, this), delete a.__parent }, this), this._map && this._generateInitialClusters(), this }, getBounds: function() { var a = new L.LatLngBounds;
            this._topClusterLevel && a.extend(this._topClusterLevel._bounds); for (var b = this._needsClustering.length - 1; b >= 0; b--) a.extend(this._needsClustering[b].getLatLng()); return a.extend(this._nonPointGroup.getBounds()), a }, eachLayer: function(a, b) { var c, d, e, f = this._needsClustering.slice(),
                g = this._needsRemoving; for (this._topClusterLevel && this._topClusterLevel.getAllChildMarkers(f), d = f.length - 1; d >= 0; d--) { for (c = !0, e = g.length - 1; e >= 0; e--)
                    if (g[e].layer === f[d]) { c = !1; break } c && a.call(b, f[d]) } this._nonPointGroup.eachLayer(a, b) }, getLayers: function() { var a = []; return this.eachLayer(function(b) { a.push(b) }), a }, getLayer: function(a) { var b = null; return a = parseInt(a, 10), this.eachLayer(function(c) { L.stamp(c) === a && (b = c) }), b }, hasLayer: function(a) { if (!a) return !1; var b, c = this._needsClustering; for (b = c.length - 1; b >= 0; b--)
                if (c[b] === a) return !0; for (c = this._needsRemoving, b = c.length - 1; b >= 0; b--)
                if (c[b].layer === a) return !1; return !(!a.__parent || a.__parent._group !== this) || this._nonPointGroup.hasLayer(a) }, zoomToShowLayer: function(a, b) { "function" != typeof b && (b = function() {}); var c = function() {!a._icon && !a.__parent._icon || this._inZoomAnimation || (this._map.off("moveend", c, this), this.off("animationend", c, this), a._icon ? b() : a.__parent._icon && (this.once("spiderfied", b, this), a.__parent.spiderfy())) };
            a._icon && this._map.getBounds().contains(a.getLatLng()) ? b() : a.__parent._zoom < Math.round(this._map._zoom) ? (this._map.on("moveend", c, this), this._map.panTo(a.getLatLng())) : (this._map.on("moveend", c, this), this.on("animationend", c, this), a.__parent.zoomToBounds()) }, onAdd: function(a) { this._map = a; var b, c, d; if (!isFinite(this._map.getMaxZoom())) throw "Map has no maxZoom specified"; for (this._featureGroup.addTo(a), this._nonPointGroup.addTo(a), this._gridClusters || this._generateInitialClusters(), this._maxLat = a.options.crs.projection.MAX_LATITUDE, b = 0, c = this._needsRemoving.length; c > b; b++) d = this._needsRemoving[b], d.newlatlng = d.layer._latlng, d.layer._latlng = d.latlng; for (b = 0, c = this._needsRemoving.length; c > b; b++) d = this._needsRemoving[b], this._removeLayer(d.layer, !0), d.layer._latlng = d.newlatlng;
            this._needsRemoving = [], this._zoom = Math.round(this._map._zoom), this._currentShownBounds = this._getExpandedVisibleBounds(), this._map.on("zoomend", this._zoomEnd, this), this._map.on("moveend", this._moveEnd, this), this._spiderfierOnAdd && this._spiderfierOnAdd(), this._bindEvents(), c = this._needsClustering, this._needsClustering = [], this.addLayers(c, !0) }, onRemove: function(a) { a.off("zoomend", this._zoomEnd, this), a.off("moveend", this._moveEnd, this), this._unbindEvents(), this._map._mapPane.className = this._map._mapPane.className.replace(" leaflet-cluster-anim", ""), this._spiderfierOnRemove && this._spiderfierOnRemove(), delete this._maxLat, this._hideCoverage(), this._featureGroup.remove(), this._nonPointGroup.remove(), this._featureGroup.clearLayers(), this._map = null }, getVisibleParent: function(a) { for (var b = a; b && !b._icon;) b = b.__parent; return b || null }, _arraySplice: function(a, b) { for (var c = a.length - 1; c >= 0; c--)
                if (a[c] === b) return a.splice(c, 1), !0 }, _removeFromGridUnclustered: function(a, b) { for (var c = this._map, d = this._gridUnclustered, e = Math.floor(this._map.getMinZoom()); b >= e && d[b].removeObject(a, c.project(a.getLatLng(), b)); b--); }, _childMarkerDragStart: function(a) { a.target.__dragStart = a.target._latlng }, _childMarkerMoved: function(a) { if (!this._ignoreMove && !a.target.__dragStart) { var b = a.target._popup && a.target._popup.isOpen();
                this._moveChild(a.target, a.oldLatLng, a.latlng), b && a.target.openPopup() } }, _moveChild: function(a, b, c) { a._latlng = b, this.removeLayer(a), a._latlng = c, this.addLayer(a) }, _childMarkerDragEnd: function(a) { var b = a.target.__dragStart;
            delete a.target.__dragStart, b && this._moveChild(a.target, b, a.target._latlng) }, _removeLayer: function(a, b, c) { var d = this._gridClusters,
                e = this._gridUnclustered,
                f = this._featureGroup,
                g = this._map,
                h = Math.floor(this._map.getMinZoom());
            b && this._removeFromGridUnclustered(a, this._maxZoom); var i, j = a.__parent,
                k = j._markers; for (this._arraySplice(k, a); j && (j._childCount--, j._boundsNeedUpdate = !0, !(j._zoom < h));) b && j._childCount <= 1 ? (i = j._markers[0] === a ? j._markers[1] : j._markers[0], d[j._zoom].removeObject(j, g.project(j._cLatLng, j._zoom)), e[j._zoom].addObject(i, g.project(i.getLatLng(), j._zoom)), this._arraySplice(j.__parent._childClusters, j), j.__parent._markers.push(i), i.__parent = j.__parent, j._icon && (f.removeLayer(j), c || f.addLayer(i))) : j._iconNeedsUpdate = !0, j = j.__parent;
            delete a.__parent }, _isOrIsParent: function(a, b) { for (; b;) { if (a === b) return !0;
                b = b.parentNode } return !1 }, fire: function(a, b, c) { if (b && b.layer instanceof L.MarkerCluster) { if (b.originalEvent && this._isOrIsParent(b.layer._icon, b.originalEvent.relatedTarget)) return;
                a = "cluster" + a } L.FeatureGroup.prototype.fire.call(this, a, b, c) }, listens: function(a, b) { return L.FeatureGroup.prototype.listens.call(this, a, b) || L.FeatureGroup.prototype.listens.call(this, "cluster" + a, b) }, _defaultIconCreateFunction: function(a) { var b = a.getChildCount(),
                c = " marker-cluster-"; return c += 10 > b ? "small" : 100 > b ? "medium" : "large", new L.DivIcon({ html: "<div><span>" + b + "</span></div>", className: "marker-cluster" + c, iconSize: new L.Point(40, 40) }) }, _bindEvents: function() { var a = this._map,
                b = this.options.spiderfyOnMaxZoom,
                c = this.options.showCoverageOnHover,
                d = this.options.zoomToBoundsOnClick;
            (b || d) && this.on("clusterclick", this._zoomOrSpiderfy, this), c && (this.on("clustermouseover", this._showCoverage, this), this.on("clustermouseout", this._hideCoverage, this), a.on("zoomend", this._hideCoverage, this)) }, _zoomOrSpiderfy: function(a) { for (var b = a.layer, c = b; 1 === c._childClusters.length;) c = c._childClusters[0];
            c._zoom === this._maxZoom && c._childCount === b._childCount && this.options.spiderfyOnMaxZoom ? b.spiderfy() : this.options.zoomToBoundsOnClick && b.zoomToBounds(), a.originalEvent && 13 === a.originalEvent.keyCode && this._map._container.focus() }, _showCoverage: function(a) { var b = this._map;
            this._inZoomAnimation || (this._shownPolygon && b.removeLayer(this._shownPolygon), a.layer.getChildCount() > 2 && a.layer !== this._spiderfied && (this._shownPolygon = new L.Polygon(a.layer.getConvexHull(), this.options.polygonOptions), b.addLayer(this._shownPolygon))) }, _hideCoverage: function() { this._shownPolygon && (this._map.removeLayer(this._shownPolygon), this._shownPolygon = null) }, _unbindEvents: function() { var a = this.options.spiderfyOnMaxZoom,
                b = this.options.showCoverageOnHover,
                c = this.options.zoomToBoundsOnClick,
                d = this._map;
            (a || c) && this.off("clusterclick", this._zoomOrSpiderfy, this), b && (this.off("clustermouseover", this._showCoverage, this), this.off("clustermouseout", this._hideCoverage, this), d.off("zoomend", this._hideCoverage, this)) }, _zoomEnd: function() { this._map && (this._mergeSplitClusters(), this._zoom = Math.round(this._map._zoom), this._currentShownBounds = this._getExpandedVisibleBounds()) }, _moveEnd: function() { if (!this._inZoomAnimation) { var a = this._getExpandedVisibleBounds();
                this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, a), this._topClusterLevel._recursivelyAddChildrenToMap(null, Math.round(this._map._zoom), a), this._currentShownBounds = a } }, _generateInitialClusters: function() { var a = Math.ceil(this._map.getMaxZoom()),
                b = Math.floor(this._map.getMinZoom()),
                c = this.options.maxClusterRadius,
                d = c; "function" != typeof c && (d = function() { return c }), null !== this.options.disableClusteringAtZoom && (a = this.options.disableClusteringAtZoom - 1), this._maxZoom = a, this._gridClusters = {}, this._gridUnclustered = {}; for (var e = a; e >= b; e--) this._gridClusters[e] = new L.DistanceGrid(d(e)), this._gridUnclustered[e] = new L.DistanceGrid(d(e));
            this._topClusterLevel = new this._markerCluster(this, b - 1) }, _addLayer: function(a, b) { var c, d, e = this._gridClusters,
                f = this._gridUnclustered,
                g = Math.floor(this._map.getMinZoom()); for (this.options.singleMarkerMode && this._overrideMarkerIcon(a), a.on(this._childMarkerEventHandlers, this); b >= g; b--) { c = this._map.project(a.getLatLng(), b); var h = e[b].getNearObject(c); if (h) return h._addChild(a), void(a.__parent = h); if (h = f[b].getNearObject(c)) { var i = h.__parent;
                    i && this._removeLayer(h, !1); var j = new this._markerCluster(this, b, h, a);
                    e[b].addObject(j, this._map.project(j._cLatLng, b)), h.__parent = j, a.__parent = j; var k = j; for (d = b - 1; d > i._zoom; d--) k = new this._markerCluster(this, d, k), e[d].addObject(k, this._map.project(h.getLatLng(), d)); return i._addChild(k), void this._removeFromGridUnclustered(h, b) } f[b].addObject(a, c) } this._topClusterLevel._addChild(a), a.__parent = this._topClusterLevel }, _refreshClustersIcons: function() { this._featureGroup.eachLayer(function(a) { a instanceof L.MarkerCluster && a._iconNeedsUpdate && a._updateIcon() }) }, _enqueue: function(a) { this._queue.push(a), this._queueTimeout || (this._queueTimeout = setTimeout(L.bind(this._processQueue, this), 300)) }, _processQueue: function() { for (var a = 0; a < this._queue.length; a++) this._queue[a].call(this);
            this._queue.length = 0, clearTimeout(this._queueTimeout), this._queueTimeout = null }, _mergeSplitClusters: function() { var a = Math.round(this._map._zoom);
            this._processQueue(), this._zoom < a && this._currentShownBounds.intersects(this._getExpandedVisibleBounds()) ? (this._animationStart(), this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, this._getExpandedVisibleBounds()), this._animationZoomIn(this._zoom, a)) : this._zoom > a ? (this._animationStart(), this._animationZoomOut(this._zoom, a)) : this._moveEnd() }, _getExpandedVisibleBounds: function() { return this.options.removeOutsideVisibleBounds ? L.Browser.mobile ? this._checkBoundsMaxLat(this._map.getBounds()) : this._checkBoundsMaxLat(this._map.getBounds().pad(1)) : this._mapBoundsInfinite }, _checkBoundsMaxLat: function(a) { var b = this._maxLat; return void 0 !== b && (a.getNorth() >= b && (a._northEast.lat = 1 / 0), a.getSouth() <= -b && (a._southWest.lat = -1 / 0)), a }, _animationAddLayerNonAnimated: function(a, b) { if (b === a) this._featureGroup.addLayer(a);
            else if (2 === b._childCount) { b._addToMap(); var c = b.getAllChildMarkers();
                this._featureGroup.removeLayer(c[0]), this._featureGroup.removeLayer(c[1]) } else b._updateIcon() }, _extractNonGroupLayers: function(a, b) { var c, d = a.getLayers(),
                e = 0; for (b = b || []; e < d.length; e++) c = d[e], c instanceof L.LayerGroup ? this._extractNonGroupLayers(c, b) : b.push(c); return b }, _overrideMarkerIcon: function(a) { var b = a.options.icon = this.options.iconCreateFunction({ getChildCount: function() { return 1 }, getAllChildMarkers: function() { return [a] } }); return b } });
    L.MarkerClusterGroup.include({ _mapBoundsInfinite: new L.LatLngBounds(new L.LatLng(-1 / 0, -1 / 0), new L.LatLng(1 / 0, 1 / 0)) }), L.MarkerClusterGroup.include({ _noAnimation: { _animationStart: function() {}, _animationZoomIn: function(a, b) { this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), a), this._topClusterLevel._recursivelyAddChildrenToMap(null, b, this._getExpandedVisibleBounds()), this.fire("animationend") }, _animationZoomOut: function(a, b) { this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), a), this._topClusterLevel._recursivelyAddChildrenToMap(null, b, this._getExpandedVisibleBounds()), this.fire("animationend") }, _animationAddLayer: function(a, b) { this._animationAddLayerNonAnimated(a, b) } }, _withAnimation: { _animationStart: function() { this._map._mapPane.className += " leaflet-cluster-anim", this._inZoomAnimation++ }, _animationZoomIn: function(a, b) { var c, d = this._getExpandedVisibleBounds(),
                    e = this._featureGroup,
                    f = Math.floor(this._map.getMinZoom());
                this._ignoreMove = !0, this._topClusterLevel._recursively(d, a, f, function(f) { var g, h = f._latlng,
                        i = f._markers; for (d.contains(h) || (h = null), f._isSingleParent() && a + 1 === b ? (e.removeLayer(f), f._recursivelyAddChildrenToMap(null, b, d)) : (f.clusterHide(), f._recursivelyAddChildrenToMap(h, b, d)), c = i.length - 1; c >= 0; c--) g = i[c], d.contains(g._latlng) || e.removeLayer(g) }), this._forceLayout(), this._topClusterLevel._recursivelyBecomeVisible(d, b), e.eachLayer(function(a) { a instanceof L.MarkerCluster || !a._icon || a.clusterShow() }), this._topClusterLevel._recursively(d, a, b, function(a) { a._recursivelyRestoreChildPositions(b) }), this._ignoreMove = !1, this._enqueue(function() { this._topClusterLevel._recursively(d, a, f, function(a) { e.removeLayer(a), a.clusterShow() }), this._animationEnd() }) }, _animationZoomOut: function(a, b) { this._animationZoomOutSingle(this._topClusterLevel, a - 1, b), this._topClusterLevel._recursivelyAddChildrenToMap(null, b, this._getExpandedVisibleBounds()), this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), a, this._getExpandedVisibleBounds()) }, _animationAddLayer: function(a, b) { var c = this,
                    d = this._featureGroup;
                d.addLayer(a), b !== a && (b._childCount > 2 ? (b._updateIcon(), this._forceLayout(), this._animationStart(), a._setPos(this._map.latLngToLayerPoint(b.getLatLng())), a.clusterHide(), this._enqueue(function() { d.removeLayer(a), a.clusterShow(), c._animationEnd() })) : (this._forceLayout(), c._animationStart(), c._animationZoomOutSingle(b, this._map.getMaxZoom(), this._zoom))) } }, _animationZoomOutSingle: function(a, b, c) { var d = this._getExpandedVisibleBounds(),
                e = Math.floor(this._map.getMinZoom());
            a._recursivelyAnimateChildrenInAndAddSelfToMap(d, e, b + 1, c); var f = this;
            this._forceLayout(), a._recursivelyBecomeVisible(d, c), this._enqueue(function() { if (1 === a._childCount) { var g = a._markers[0];
                    this._ignoreMove = !0, g.setLatLng(g.getLatLng()), this._ignoreMove = !1, g.clusterShow && g.clusterShow() } else a._recursively(d, c, e, function(a) { a._recursivelyRemoveChildrenFromMap(d, e, b + 1) });
                f._animationEnd() }) }, _animationEnd: function() { this._map && (this._map._mapPane.className = this._map._mapPane.className.replace(" leaflet-cluster-anim", "")), this._inZoomAnimation--, this.fire("animationend") }, _forceLayout: function() { L.Util.falseFn(document.body.offsetWidth) } }), L.markerClusterGroup = function(a) { return new L.MarkerClusterGroup(a) };
    var c = L.MarkerCluster = L.Marker.extend({ options: L.Icon.prototype.options, initialize: function(a, b, c, d) { L.Marker.prototype.initialize.call(this, c ? c._cLatLng || c.getLatLng() : new L.LatLng(0, 0), { icon: this, pane: a.options.clusterPane }), this._group = a, this._zoom = b, this._markers = [], this._childClusters = [], this._childCount = 0, this._iconNeedsUpdate = !0, this._boundsNeedUpdate = !0, this._bounds = new L.LatLngBounds, c && this._addChild(c), d && this._addChild(d) }, getAllChildMarkers: function(a, b) { a = a || []; for (var c = this._childClusters.length - 1; c >= 0; c--) this._childClusters[c].getAllChildMarkers(a); for (var d = this._markers.length - 1; d >= 0; d--) b && this._markers[d].__dragStart || a.push(this._markers[d]); return a }, getChildCount: function() { return this._childCount }, zoomToBounds: function(a) { for (var b, c = this._childClusters.slice(), d = this._group._map, e = d.getBoundsZoom(this._bounds), f = this._zoom + 1, g = d.getZoom(); c.length > 0 && e > f;) { f++; var h = []; for (b = 0; b < c.length; b++) h = h.concat(c[b]._childClusters);
                c = h } e > f ? this._group._map.setView(this._latlng, f) : g >= e ? this._group._map.setView(this._latlng, g + 1) : this._group._map.fitBounds(this._bounds, a) }, getBounds: function() { var a = new L.LatLngBounds; return a.extend(this._bounds), a }, _updateIcon: function() { this._iconNeedsUpdate = !0, this._icon && this.setIcon(this) }, createIcon: function() { return this._iconNeedsUpdate && (this._iconObj = this._group.options.iconCreateFunction(this), this._iconNeedsUpdate = !1), this._iconObj.createIcon() }, createShadow: function() { return this._iconObj.createShadow() }, _addChild: function(a, b) { this._iconNeedsUpdate = !0, this._boundsNeedUpdate = !0, this._setClusterCenter(a), a instanceof L.MarkerCluster ? (b || (this._childClusters.push(a), a.__parent = this), this._childCount += a._childCount) : (b || this._markers.push(a), this._childCount++), this.__parent && this.__parent._addChild(a, !0) }, _setClusterCenter: function(a) { this._cLatLng || (this._cLatLng = a._cLatLng || a._latlng) }, _resetBounds: function() { var a = this._bounds;
            a._southWest && (a._southWest.lat = 1 / 0, a._southWest.lng = 1 / 0), a._northEast && (a._northEast.lat = -1 / 0, a._northEast.lng = -1 / 0) }, _recalculateBounds: function() { var a, b, c, d, e = this._markers,
                f = this._childClusters,
                g = 0,
                h = 0,
                i = this._childCount; if (0 !== i) { for (this._resetBounds(), a = 0; a < e.length; a++) c = e[a]._latlng, this._bounds.extend(c), g += c.lat, h += c.lng; for (a = 0; a < f.length; a++) b = f[a], b._boundsNeedUpdate && b._recalculateBounds(), this._bounds.extend(b._bounds), c = b._wLatLng, d = b._childCount, g += c.lat * d, h += c.lng * d;
                this._latlng = this._wLatLng = new L.LatLng(g / i, h / i), this._boundsNeedUpdate = !1 } }, _addToMap: function(a) { a && (this._backupLatlng = this._latlng, this.setLatLng(a)), this._group._featureGroup.addLayer(this) }, _recursivelyAnimateChildrenIn: function(a, b, c) { this._recursively(a, this._group._map.getMinZoom(), c - 1, function(a) { var c, d, e = a._markers; for (c = e.length - 1; c >= 0; c--) d = e[c], d._icon && (d._setPos(b), d.clusterHide()) }, function(a) { var c, d, e = a._childClusters; for (c = e.length - 1; c >= 0; c--) d = e[c], d._icon && (d._setPos(b), d.clusterHide()) }) }, _recursivelyAnimateChildrenInAndAddSelfToMap: function(a, b, c, d) { this._recursively(a, d, b, function(e) { e._recursivelyAnimateChildrenIn(a, e._group._map.latLngToLayerPoint(e.getLatLng()).round(), c), e._isSingleParent() && c - 1 === d ? (e.clusterShow(), e._recursivelyRemoveChildrenFromMap(a, b, c)) : e.clusterHide(), e._addToMap() }) }, _recursivelyBecomeVisible: function(a, b) { this._recursively(a, this._group._map.getMinZoom(), b, null, function(a) { a.clusterShow() }) }, _recursivelyAddChildrenToMap: function(a, b, c) { this._recursively(c, this._group._map.getMinZoom() - 1, b, function(d) { if (b !== d._zoom)
                    for (var e = d._markers.length - 1; e >= 0; e--) { var f = d._markers[e];
                        c.contains(f._latlng) && (a && (f._backupLatlng = f.getLatLng(), f.setLatLng(a), f.clusterHide && f.clusterHide()), d._group._featureGroup.addLayer(f)) } }, function(b) { b._addToMap(a) }) }, _recursivelyRestoreChildPositions: function(a) { for (var b = this._markers.length - 1; b >= 0; b--) { var c = this._markers[b];
                c._backupLatlng && (c.setLatLng(c._backupLatlng), delete c._backupLatlng) } if (a - 1 === this._zoom)
                for (var d = this._childClusters.length - 1; d >= 0; d--) this._childClusters[d]._restorePosition();
            else
                for (var e = this._childClusters.length - 1; e >= 0; e--) this._childClusters[e]._recursivelyRestoreChildPositions(a) }, _restorePosition: function() { this._backupLatlng && (this.setLatLng(this._backupLatlng), delete this._backupLatlng) }, _recursivelyRemoveChildrenFromMap: function(a, b, c, d) { var e, f;
            this._recursively(a, b - 1, c - 1, function(a) { for (f = a._markers.length - 1; f >= 0; f--) e = a._markers[f], d && d.contains(e._latlng) || (a._group._featureGroup.removeLayer(e), e.clusterShow && e.clusterShow()) }, function(a) { for (f = a._childClusters.length - 1; f >= 0; f--) e = a._childClusters[f], d && d.contains(e._latlng) || (a._group._featureGroup.removeLayer(e), e.clusterShow && e.clusterShow()) }) }, _recursively: function(a, b, c, d, e) { var f, g, h = this._childClusters,
                i = this._zoom; if (i >= b && (d && d(this), e && i === c && e(this)), b > i || c > i)
                for (f = h.length - 1; f >= 0; f--) g = h[f], g._boundsNeedUpdate && g._recalculateBounds(), a.intersects(g._bounds) && g._recursively(a, b, c, d, e) }, _isSingleParent: function() { return this._childClusters.length > 0 && this._childClusters[0]._childCount === this._childCount } });
    L.Marker.include({ clusterHide: function() { var a = this.options.opacity; return this.setOpacity(0), this.options.opacity = a, this }, clusterShow: function() { return this.setOpacity(this.options.opacity) } }), L.DistanceGrid = function(a) { this._cellSize = a, this._sqCellSize = a * a, this._grid = {}, this._objectPoint = {} }, L.DistanceGrid.prototype = { addObject: function(a, b) { var c = this._getCoord(b.x),
                    d = this._getCoord(b.y),
                    e = this._grid,
                    f = e[d] = e[d] || {},
                    g = f[c] = f[c] || [],
                    h = L.Util.stamp(a);
                this._objectPoint[h] = b, g.push(a) }, updateObject: function(a, b) { this.removeObject(a), this.addObject(a, b) }, removeObject: function(a, b) { var c, d, e = this._getCoord(b.x),
                    f = this._getCoord(b.y),
                    g = this._grid,
                    h = g[f] = g[f] || {},
                    i = h[e] = h[e] || []; for (delete this._objectPoint[L.Util.stamp(a)], c = 0, d = i.length; d > c; c++)
                    if (i[c] === a) return i.splice(c, 1), 1 === d && delete h[e], !0 }, eachObject: function(a, b) { var c, d, e, f, g, h, i, j = this._grid; for (c in j) { g = j[c]; for (d in g)
                        for (h = g[d], e = 0, f = h.length; f > e; e++) i = a.call(b, h[e]), i && (e--, f--) } }, getNearObject: function(a) { var b, c, d, e, f, g, h, i, j = this._getCoord(a.x),
                    k = this._getCoord(a.y),
                    l = this._objectPoint,
                    m = this._sqCellSize,
                    n = null; for (b = k - 1; k + 1 >= b; b++)
                    if (e = this._grid[b])
                        for (c = j - 1; j + 1 >= c; c++)
                            if (f = e[c])
                                for (d = 0, g = f.length; g > d; d++) h = f[d], i = this._sqDist(l[L.Util.stamp(h)], a), (m > i || m >= i && null === n) && (m = i, n = h); return n }, _getCoord: function(a) { var b = Math.floor(a / this._cellSize); return isFinite(b) ? b : a }, _sqDist: function(a, b) { var c = b.x - a.x,
                    d = b.y - a.y; return c * c + d * d } },
        function() { L.QuickHull = { getDistant: function(a, b) { var c = b[1].lat - b[0].lat,
                        d = b[0].lng - b[1].lng; return d * (a.lat - b[0].lat) + c * (a.lng - b[0].lng) }, findMostDistantPointFromBaseLine: function(a, b) { var c, d, e, f = 0,
                        g = null,
                        h = []; for (c = b.length - 1; c >= 0; c--) d = b[c], e = this.getDistant(d, a), e > 0 && (h.push(d), e > f && (f = e, g = d)); return { maxPoint: g, newPoints: h } }, buildConvexHull: function(a, b) { var c = [],
                        d = this.findMostDistantPointFromBaseLine(a, b); return d.maxPoint ? (c = c.concat(this.buildConvexHull([a[0], d.maxPoint], d.newPoints)), c = c.concat(this.buildConvexHull([d.maxPoint, a[1]], d.newPoints))) : [a[0]] }, getConvexHull: function(a) { var b, c = !1,
                        d = !1,
                        e = !1,
                        f = !1,
                        g = null,
                        h = null,
                        i = null,
                        j = null,
                        k = null,
                        l = null; for (b = a.length - 1; b >= 0; b--) { var m = a[b];
                        (c === !1 || m.lat > c) && (g = m, c = m.lat), (d === !1 || m.lat < d) && (h = m, d = m.lat), (e === !1 || m.lng > e) && (i = m, e = m.lng), (f === !1 || m.lng < f) && (j = m, f = m.lng) } d !== c ? (l = h, k = g) : (l = j, k = i); var n = [].concat(this.buildConvexHull([l, k], a), this.buildConvexHull([k, l], a)); return n } } }(), L.MarkerCluster.include({ getConvexHull: function() { var a, b, c = this.getAllChildMarkers(),
                    d = []; for (b = c.length - 1; b >= 0; b--) a = c[b].getLatLng(), d.push(a); return L.QuickHull.getConvexHull(d) } }), L.MarkerCluster.include({ _2PI: 2 * Math.PI, _circleFootSeparation: 25, _circleStartAngle: 0, _spiralFootSeparation: 28, _spiralLengthStart: 11, _spiralLengthFactor: 5, _circleSpiralSwitchover: 9, spiderfy: function() { if (this._group._spiderfied !== this && !this._group._inZoomAnimation) { var a, b = this.getAllChildMarkers(null, !0),
                        c = this._group,
                        d = c._map,
                        e = d.latLngToLayerPoint(this._latlng);
                    this._group._unspiderfy(), this._group._spiderfied = this, b.length >= this._circleSpiralSwitchover ? a = this._generatePointsSpiral(b.length, e) : (e.y += 10, a = this._generatePointsCircle(b.length, e)), this._animationSpiderfy(b, a) } }, unspiderfy: function(a) { this._group._inZoomAnimation || (this._animationUnspiderfy(a), this._group._spiderfied = null) }, _generatePointsCircle: function(a, b) { var c, d, e = this._group.options.spiderfyDistanceMultiplier * this._circleFootSeparation * (2 + a),
                    f = e / this._2PI,
                    g = this._2PI / a,
                    h = []; for (f = Math.max(f, 35), h.length = a, c = 0; a > c; c++) d = this._circleStartAngle + c * g, h[c] = new L.Point(b.x + f * Math.cos(d), b.y + f * Math.sin(d))._round(); return h }, _generatePointsSpiral: function(a, b) { var c, d = this._group.options.spiderfyDistanceMultiplier,
                    e = d * this._spiralLengthStart,
                    f = d * this._spiralFootSeparation,
                    g = d * this._spiralLengthFactor * this._2PI,
                    h = 0,
                    i = []; for (i.length = a, c = a; c >= 0; c--) a > c && (i[c] = new L.Point(b.x + e * Math.cos(h), b.y + e * Math.sin(h))._round()), h += f / e + 5e-4 * c, e += g / h; return i }, _noanimationUnspiderfy: function() { var a, b, c = this._group,
                    d = c._map,
                    e = c._featureGroup,
                    f = this.getAllChildMarkers(null, !0); for (c._ignoreMove = !0, this.setOpacity(1), b = f.length - 1; b >= 0; b--) a = f[b], e.removeLayer(a), a._preSpiderfyLatlng && (a.setLatLng(a._preSpiderfyLatlng), delete a._preSpiderfyLatlng), a.setZIndexOffset && a.setZIndexOffset(0), a._spiderLeg && (d.removeLayer(a._spiderLeg), delete a._spiderLeg);
                c.fire("unspiderfied", { cluster: this, markers: f }), c._ignoreMove = !1, c._spiderfied = null } }), L.MarkerClusterNonAnimated = L.MarkerCluster.extend({ _animationSpiderfy: function(a, b) { var c, d, e, f, g = this._group,
                    h = g._map,
                    i = g._featureGroup,
                    j = this._group.options.spiderLegPolylineOptions; for (g._ignoreMove = !0, c = 0; c < a.length; c++) f = h.layerPointToLatLng(b[c]), d = a[c], e = new L.Polyline([this._latlng, f], j), h.addLayer(e), d._spiderLeg = e, d._preSpiderfyLatlng = d._latlng, d.setLatLng(f), d.setZIndexOffset && d.setZIndexOffset(1e6), i.addLayer(d);
                this.setOpacity(.3), g._ignoreMove = !1, g.fire("spiderfied", { cluster: this, markers: a }) }, _animationUnspiderfy: function() { this._noanimationUnspiderfy() } }), L.MarkerCluster.include({ _animationSpiderfy: function(a, b) { var c, d, e, f, g, h, i = this,
                    j = this._group,
                    k = j._map,
                    l = j._featureGroup,
                    m = this._latlng,
                    n = k.latLngToLayerPoint(m),
                    o = L.Path.SVG,
                    p = L.extend({}, this._group.options.spiderLegPolylineOptions),
                    q = p.opacity; for (void 0 === q && (q = L.MarkerClusterGroup.prototype.options.spiderLegPolylineOptions.opacity), o ? (p.opacity = 0, p.className = (p.className || "") + " leaflet-cluster-spider-leg") : p.opacity = q, j._ignoreMove = !0, c = 0; c < a.length; c++) d = a[c], h = k.layerPointToLatLng(b[c]), e = new L.Polyline([m, h], p), k.addLayer(e), d._spiderLeg = e, o && (f = e._path, g = f.getTotalLength() + .1, f.style.strokeDasharray = g, f.style.strokeDashoffset = g), d.setZIndexOffset && d.setZIndexOffset(1e6), d.clusterHide && d.clusterHide(), l.addLayer(d), d._setPos && d._setPos(n); for (j._forceLayout(), j._animationStart(), c = a.length - 1; c >= 0; c--) h = k.layerPointToLatLng(b[c]), d = a[c], d._preSpiderfyLatlng = d._latlng, d.setLatLng(h), d.clusterShow && d.clusterShow(), o && (e = d._spiderLeg, f = e._path, f.style.strokeDashoffset = 0, e.setStyle({ opacity: q }));
                this.setOpacity(.3), j._ignoreMove = !1, setTimeout(function() { j._animationEnd(), j.fire("spiderfied", { cluster: i, markers: a }) }, 200) }, _animationUnspiderfy: function(a) { var b, c, d, e, f, g, h = this,
                    i = this._group,
                    j = i._map,
                    k = i._featureGroup,
                    l = a ? j._latLngToNewLayerPoint(this._latlng, a.zoom, a.center) : j.latLngToLayerPoint(this._latlng),
                    m = this.getAllChildMarkers(null, !0),
                    n = L.Path.SVG; for (i._ignoreMove = !0, i._animationStart(), this.setOpacity(1), c = m.length - 1; c >= 0; c--) b = m[c], b._preSpiderfyLatlng && (b.closePopup(), b.setLatLng(b._preSpiderfyLatlng), delete b._preSpiderfyLatlng, g = !0, b._setPos && (b._setPos(l), g = !1), b.clusterHide && (b.clusterHide(), g = !1), g && k.removeLayer(b), n && (d = b._spiderLeg, e = d._path, f = e.getTotalLength() + .1, e.style.strokeDashoffset = f, d.setStyle({ opacity: 0 })));
                i._ignoreMove = !1, setTimeout(function() { var a = 0; for (c = m.length - 1; c >= 0; c--) b = m[c], b._spiderLeg && a++; for (c = m.length - 1; c >= 0; c--) b = m[c], b._spiderLeg && (b.clusterShow && b.clusterShow(), b.setZIndexOffset && b.setZIndexOffset(0), a > 1 && k.removeLayer(b), j.removeLayer(b._spiderLeg), delete b._spiderLeg);
                    i._animationEnd(), i.fire("unspiderfied", { cluster: h, markers: m }) }, 200) } }), L.MarkerClusterGroup.include({
            _spiderfied: null,
            unspiderfy: function() { this._unspiderfy.apply(this, arguments) },
            _spiderfierOnAdd: function() { this._map.on("click", this._unspiderfyWrapper, this), this._map.options.zoomAnimation && this._map.on("zoomstart", this._unspiderfyZoomStart, this), this._map.on("zoomend", this._noanimationUnspiderfy, this), L.Browser.touch || this._map.getRenderer(this) },
            _spiderfierOnRemove: function() {
                this._map.off("click", this._unspiderfyWrapper, this), this._map.off("zoomstart", this._unspiderfyZoomStart, this), this._map.off("zoomanim", this._unspiderfyZoomAnim, this), this._map.off("zoomend", this._noanimationUnspiderfy, this),
                    this._noanimationUnspiderfy()
            },
            _unspiderfyZoomStart: function() { this._map && this._map.on("zoomanim", this._unspiderfyZoomAnim, this) },
            _unspiderfyZoomAnim: function(a) { L.DomUtil.hasClass(this._map._mapPane, "leaflet-touching") || (this._map.off("zoomanim", this._unspiderfyZoomAnim, this), this._unspiderfy(a)) },
            _unspiderfyWrapper: function() { this._unspiderfy() },
            _unspiderfy: function(a) { this._spiderfied && this._spiderfied.unspiderfy(a) },
            _noanimationUnspiderfy: function() { this._spiderfied && this._spiderfied._noanimationUnspiderfy() },
            _unspiderfyLayer: function(a) { a._spiderLeg && (this._featureGroup.removeLayer(a), a.clusterShow && a.clusterShow(), a.setZIndexOffset && a.setZIndexOffset(0), this._map.removeLayer(a._spiderLeg), delete a._spiderLeg) }
        }), L.MarkerClusterGroup.include({ refreshClusters: function(a) { return a ? a instanceof L.MarkerClusterGroup ? a = a._topClusterLevel.getAllChildMarkers() : a instanceof L.LayerGroup ? a = a._layers : a instanceof L.MarkerCluster ? a = a.getAllChildMarkers() : a instanceof L.Marker && (a = [a]) : a = this._topClusterLevel.getAllChildMarkers(), this._flagParentsIconsNeedUpdate(a), this._refreshClustersIcons(), this.options.singleMarkerMode && this._refreshSingleMarkerModeMarkers(a), this }, _flagParentsIconsNeedUpdate: function(a) { var b, c; for (b in a)
                    for (c = a[b].__parent; c;) c._iconNeedsUpdate = !0, c = c.__parent }, _refreshSingleMarkerModeMarkers: function(a) { var b, c; for (b in a) c = a[b], this.hasLayer(c) && c.setIcon(this._overrideMarkerIcon(c)) } }), L.Marker.include({ refreshIconOptions: function(a, b) { var c = this.options.icon; return L.setOptions(c, a), this.setIcon(c), b && this.__parent && this.__parent._group.refreshClusters(this), this } }), a.MarkerClusterGroup = b, a.MarkerCluster = c
}),
function(a, b) { "function" == typeof define && define.amd ? define(["leaflet"], a) : "object" == typeof exports && ("undefined" != typeof b && b.L ? module.exports = a(L) : module.exports = a(require("leaflet"))), "undefined" != typeof b && b.L && (b.L.Locate = a(L)) }(function(a) { return a.geo = { location: !1, locationWatchId: !1 }, a.Map.include({ _defaultLocateOptions: { watch: !1, setView: !1, maxZoom: 1 / 0, timeout: 1e4, maximumAge: 0, enableHighAccuracy: !1 }, locate: function(b) { if (b = this._locateOptions = a.extend(this._defaultLocateOptions, b), !navigator.geolocation) return this._handleGeolocationError({ code: 0, message: "Geolocation not supported." }), this; var c = a.bind(this._handleGeolocationResponse, this),
                    d = a.bind(this._handleGeolocationError, this); return a.geo.location ? c(a.geo.location) : b.watch ? locationWatchId = navigator.geolocation.watchPosition(c, d, b) : navigator.geolocation.getCurrentPosition(c, d, b), this }, stopLocate: function() { return navigator.geolocation && navigator.geolocation.clearWatch(a.geo.locationWatchId), this._locateOptions && (this._locateOptions.setView = !1), this }, _handleGeolocationError: function(a) { var b = a.code,
                    c = a.message || (1 === b ? "permission denied" : 2 === b ? "position unavailable" : "timeout");
                this._locateOptions.setView && !this._loaded && this.fitWorld(), this.fire("locationerror", { code: b, message: "Geolocation error: " + c + "." }) }, _handleGeolocationResponse: function(b) { a.geo.location = b; var c = b.coords.latitude,
                    d = b.coords.longitude,
                    e = new a.LatLng(c, d),
                    f = 180 * b.coords.accuracy / 40075017,
                    g = f / Math.cos(a.LatLng.DEG_TO_RAD * c),
                    h = a.latLngBounds([c - f, d - g], [c + f, d + g]),
                    i = this._locateOptions; if (i.setView) { var j = Math.min(this.getBoundsZoom(h), i.maxZoom);
                    this.setView(e, j) } var k = { latlng: e, bounds: h, timestamp: b.timestamp }; for (var l in b.coords) "number" == typeof b.coords[l] && (k[l] = b.coords[l]);
                a.geo.data = k, this.fire("locationfound", k) } }), a.Control.Locate = a.Control.extend({ options: { position: "topleft", layer: new a.LayerGroup, drawCircle: !0, follow: !1, stopFollowingOnDrag: !1, remainActive: !1, markerClass: a.circleMarker, circleStyle: { color: "#136AEC", fillColor: "#136AEC", fillOpacity: .15, weight: 2, opacity: .5 }, markerStyle: { color: "#136AEC", fillColor: "#2A93EE", fillOpacity: .7, weight: 2, opacity: .9, radius: 5 }, followCircleStyle: {}, followMarkerStyle: {}, icon: "fa fa-map-marker", iconLoading: "fa fa-spinner fa-spin", circlePadding: [0, 0], metric: !0, onLocationError: function(a) { alert(a.message) }, onLocationOutsideMapBounds: function(a) { a.stop(), alert(a.options.strings.outsideMapBoundsMsg) }, setView: !0, keepCurrentZoomLevel: !1, showPopup: !0, strings: { title: "Show your location", metersUnit: "meters", feetUnit: "feet", popup: "You are within {distance} {unit} of this point", outsideMapBoundsMsg: "You seem located outside the boundaries of the map" }, locateOptions: { maxZoom: 1 / 0, watch: !0 } }, initialize: function(b) { a.Map.addInitHook(function() { this.options.locateControl && this.addControl(this) }); for (var c in b) "object" == typeof this.options[c] ? a.extend(this.options[c], b[c]) : this.options[c] = b[c];
                a.extend(this.options.locateOptions, { setView: !1 }) }, _activate: function() { this.options.setView && (this._locateOnNextLocationFound = !0), this._active || (this._active = !0, this._map.locate(this.options.locateOptions)), this._active = !0, this.options.follow && this._startFollowing(this._map) }, _deactivate: function() { this._map.stopLocate(), this._map.off("dragstart", this._stopFollowing, this), this.options.follow && this._following && this._stopFollowing(this._map) }, drawMarker: function(b) { void 0 === this._event.accuracy && (this._event.accuracy = 0); var c = this._event.accuracy;
                this._locateOnNextLocationFound && (this._isOutsideMapBounds() ? this.options.onLocationOutsideMapBounds(this) : this.options.keepCurrentZoomLevel || !this.options.drawCircle ? b.panTo([this._event.latitude, this._event.longitude]) : b.fitBounds(this._event.bounds, { padding: this.options.circlePadding, maxZoom: this.options.keepCurrentZoomLevel ? b.getZoom() : this.options.locateOptions.maxZoom }), this._locateOnNextLocationFound = !1); var d, e; if (this.options.drawCircle)
                    if (d = this._following ? this.options.followCircleStyle : this.options.circleStyle, this._circle) { this._circle.setLatLng(this._event.latlng).setRadius(c); for (e in d) this._circle.options[e] = d[e] } else this._circle = a.circle(this._event.latlng, c, d).addTo(this._layer); var f, g;
                this.options.metric ? (f = c.toFixed(0), g = this.options.strings.metersUnit) : (f = (3.2808399 * c).toFixed(0), g = this.options.strings.feetUnit); var h;
                h = this._following ? this.options.followMarkerStyle : this.options.markerStyle, this._marker ? this.updateMarker(this._event.latlng, h) : this._marker = this.createMarker(this._event.latlng, h).addTo(this._layer); var i = this.options.strings.popup;
                this.options.showPopup && i && this._marker.bindPopup(a.Util.template(i, { distance: f, unit: g }))._popup.setLatLng(this._event.latlng), this._toggleContainerStyle() }, createMarker: function(a, b) { return this.options.markerClass(a, b) }, updateMarker: function(a, b) { this._marker.setLatLng(a); for (var c in b) this._marker.options[c] = b[c] }, removeMarker: function() { this._layer.clearLayers(), this._marker = void 0, this._circle = void 0 }, onAdd: function(b) { var c = a.DomUtil.create("div", "leaflet-control-locate leaflet-bar leaflet-control");
                this._layer = a.layerGroup(), this._layer.addTo(b), this._event = void 0; var d = {}; return a.extend(d, this.options.markerStyle, this.options.followMarkerStyle), this.options.followMarkerStyle = d, d = {}, a.extend(d, this.options.circleStyle, this.options.followCircleStyle), this.options.followCircleStyle = d, this._link = a.DomUtil.create("a", "leaflet-bar-part leaflet-bar-part-single", c), this._link.href = "#", this._link.title = this.options.strings.title, this._icon = a.DomUtil.create("span", this.options.icon, this._link), a.DomEvent.on(this._link, "click", a.DomEvent.stopPropagation).on(this._link, "click", a.DomEvent.preventDefault).on(this._link, "click", function() { var a = void 0 === this._event || this._map.getBounds().contains(this._event.latlng) || !this.options.setView || this._isOutsideMapBounds();!this.options.remainActive && this._active && a ? this.stop() : this.start() }, this).on(this._link, "dblclick", a.DomEvent.stopPropagation), this._resetVariables(), this.bindEvents(b), c }, bindEvents: function(a) { a.on("locationfound", this._onLocationFound, this), a.on("locationerror", this._onLocationError, this), a.on("unload", this.stop, this) }, start: function() { this._activate(), this._event ? this.drawMarker(this._map) : this._setClasses("requesting") }, stop: function() { this._deactivate(), this._cleanClasses(), this._resetVariables(), this.removeMarker() }, _onLocationError: function(a) { 3 == a.code && this.options.locateOptions.watch || (this.stop(), this.options.onLocationError(a)) }, _onLocationFound: function(a) { this._event && this._event.latlng.lat === a.latlng.lat && this._event.latlng.lng === a.latlng.lng && this._event.accuracy === a.accuracy || this._active && (this._event = a, this.options.follow && this._following && (this._locateOnNextLocationFound = !0), this.drawMarker(this._map)) }, _startFollowing: function() { this._map.fire("startfollowing", this), this._following = !0, this.options.stopFollowingOnDrag && this._map.on("dragstart", this._stopFollowing, this) }, _stopFollowing: function() { this._map.fire("stopfollowing", this), this._following = !1, this.options.stopFollowingOnDrag && this._map.off("dragstart", this._stopFollowing, this), this._toggleContainerStyle() }, _isOutsideMapBounds: function() { return void 0 !== this._event && (this._map.options.maxBounds && !this._map.options.maxBounds.contains(this._event.latlng)) }, _toggleContainerStyle: function() { this._container && (this._following ? this._setClasses("following") : this._setClasses("active")) }, _setClasses: function(b) { "requesting" == b ? (a.DomUtil.removeClasses(this._container, "active following"), a.DomUtil.addClasses(this._container, "requesting"), a.DomUtil.removeClasses(this._icon, this.options.icon), a.DomUtil.addClasses(this._icon, this.options.iconLoading)) : "active" == b ? (a.DomUtil.removeClasses(this._container, "requesting following"), a.DomUtil.addClasses(this._container, "active"), a.DomUtil.removeClasses(this._icon, this.options.iconLoading), a.DomUtil.addClasses(this._icon, this.options.icon)) : "following" == b && (a.DomUtil.removeClasses(this._container, "requesting"), a.DomUtil.addClasses(this._container, "active following"), a.DomUtil.removeClasses(this._icon, this.options.iconLoading), a.DomUtil.addClasses(this._icon, this.options.icon)) }, _cleanClasses: function() { a.DomUtil.removeClass(this._container, "requesting"), a.DomUtil.removeClass(this._container, "active"), a.DomUtil.removeClass(this._container, "following"), a.DomUtil.removeClasses(this._icon, this.options.iconLoading), a.DomUtil.addClasses(this._icon, this.options.icon) }, _resetVariables: function() { this._active = !1, this._locateOnNextLocationFound = this.options.setView, this._following = !1 } }), a.control.locate = function(b) { return new a.Control.Locate(b) },
        function() { var b = function(b, c, d) { d = d.split(" "), d.forEach(function(d) { a.DomUtil[b].call(this, c, d) }) };
            a.DomUtil.addClasses = function(a, c) { b("addClass", a, c) }, a.DomUtil.removeClasses = function(a, c) { b("removeClass", a, c) } }(), a.Control.Locate }, window),
function(a, b, c) {
    L.drawVersion = "0.2.4-dev", L.drawLocal = { draw: { toolbar: { actions: { title: "Cancel drawing", text: "Cancel" }, undo: { title: "Delete last point drawn", text: "Delete last point" }, buttons: { polyline: "Draw a polyline", polygon: "Draw a polygon", rectangle: "Draw a rectangle", circle: "Draw a circle", marker: "Draw a marker" } }, handlers: { circle: { tooltip: { start: "Click and drag to draw circle." }, radius: "Radius" }, marker: { tooltip: { start: "Click map to place marker." } }, polygon: { tooltip: { start: "Click to start drawing shape.", cont: "Click to continue drawing shape.", end: "Click first point to close this shape." } }, polyline: { error: "<strong>Error:</strong> shape edges cannot cross!", tooltip: { start: "Click to start drawing line.", cont: "Click to continue drawing line.", end: "Click last point to finish line." } }, rectangle: { tooltip: { start: "Click and drag to draw rectangle." } }, simpleshape: { tooltip: { end: "Release mouse to finish drawing." } } } }, edit: { toolbar: { actions: { save: { title: "Save changes.", text: "Save" }, cancel: { title: "Cancel editing, discards all changes.", text: "Cancel" } }, buttons: { edit: "Edit layers.", editDisabled: "No layers to edit.", remove: "Delete layers.", removeDisabled: "No layers to delete." } }, handlers: { edit: { tooltip: { text: "Drag handles, or marker to edit feature.", subtext: "Click cancel to undo changes." } }, remove: { tooltip: { text: "Click on a feature to remove" } } } } }, L.Draw = {}, L.Draw.Feature = L.Handler.extend({ includes: L.Mixin.Events, initialize: function(a, b) { this._map = a, this._container = a._container, this._overlayPane = a._panes.overlayPane, this._popupPane = a._panes.popupPane, b && b.shapeOptions && (b.shapeOptions = L.Util.extend({}, this.options.shapeOptions, b.shapeOptions)), L.setOptions(this, b) }, enable: function() { this._enabled || (L.Handler.prototype.enable.call(this), this.fire("enabled", { handler: this.type }), this._map.fire("draw:drawstart", { layerType: this.type })) }, disable: function() { this._enabled && (L.Handler.prototype.disable.call(this), this._map.fire("draw:drawstop", { layerType: this.type }), this.fire("disabled", { handler: this.type })) }, addHooks: function() { var a = this._map;
            a && (L.DomUtil.disableTextSelection(), a.getContainer().focus(), this._tooltip = new L.Tooltip(this._map), L.DomEvent.on(this._container, "keyup", this._cancelDrawing, this)) }, removeHooks: function() { this._map && (L.DomUtil.enableTextSelection(), this._tooltip.dispose(), this._tooltip = null, L.DomEvent.off(this._container, "keyup", this._cancelDrawing, this)) }, setOptions: function(a) { L.setOptions(this, a) }, _fireCreatedEvent: function(a) { this._map.fire("draw:created", { layer: a, layerType: this.type }) }, _cancelDrawing: function(a) { 27 === a.keyCode && this.disable() } }), L.Draw.Polyline = L.Draw.Feature.extend({ statics: { TYPE: "polyline" }, Poly: L.Polyline, options: { allowIntersection: !0, repeatMode: !1, drawError: { color: "#b00b00", timeout: 2500 }, icon: new L.DivIcon({ iconSize: new L.Point(8, 8), className: "leaflet-div-icon leaflet-editing-icon" }), guidelineDistance: 20, maxGuideLineLength: 4e3, shapeOptions: { stroke: !0, color: "#f06eaa", weight: 4, opacity: .5, fill: !1, clickable: !0 }, metric: !0, showLength: !0, zIndexOffset: 2e3 }, initialize: function(a, b) { this.options.drawError.message = L.drawLocal.draw.handlers.polyline.error, b && b.drawError && (b.drawError = L.Util.extend({}, this.options.drawError, b.drawError)), this.type = L.Draw.Polyline.TYPE, L.Draw.Feature.prototype.initialize.call(this, a, b) }, addHooks: function() { L.Draw.Feature.prototype.addHooks.call(this), this._map && (this._markers = [], this._markerGroup = new L.LayerGroup, this._map.addLayer(this._markerGroup), this._poly = new L.Polyline([], this.options.shapeOptions), this._tooltip.updateContent(this._getTooltipText()), this._mouseMarker || (this._mouseMarker = L.marker(this._map.getCenter(), { icon: L.divIcon({ className: "leaflet-mouse-marker", iconAnchor: [20, 20], iconSize: [40, 40] }), opacity: 0, zIndexOffset: this.options.zIndexOffset })), this._mouseMarker.on("mousedown", this._onMouseDown, this).addTo(this._map), this._map.on("mousemove", this._onMouseMove, this).on("mouseup", this._onMouseUp, this).on("zoomend", this._onZoomEnd, this)) }, removeHooks: function() { L.Draw.Feature.prototype.removeHooks.call(this), this._clearHideErrorTimeout(), this._cleanUpShape(), this._map.removeLayer(this._markerGroup), delete this._markerGroup, delete this._markers, this._map.removeLayer(this._poly), delete this._poly, this._mouseMarker.off("mousedown", this._onMouseDown, this).off("mouseup", this._onMouseUp, this), this._map.removeLayer(this._mouseMarker), delete this._mouseMarker, this._clearGuides(), this._map.off("mousemove", this._onMouseMove, this).off("zoomend", this._onZoomEnd, this) }, deleteLastVertex: function() { if (!(this._markers.length <= 1)) { var a = this._markers.pop(),
                    b = this._poly,
                    c = this._poly.spliceLatLngs(b.getLatLngs().length - 1, 1)[0];
                this._markerGroup.removeLayer(a), b.getLatLngs().length < 2 && this._map.removeLayer(b), this._vertexChanged(c, !1) } }, addVertex: function(a) { var b = this._markers.length; return b > 0 && !this.options.allowIntersection && this._poly.newLatLngIntersects(a) ? void this._showErrorTooltip() : (this._errorShown && this._hideErrorTooltip(), this._markers.push(this._createMarker(a)), this._poly.addLatLng(a), 2 === this._poly.getLatLngs().length && this._map.addLayer(this._poly), void this._vertexChanged(a, !0)) }, _finishShape: function() { var a = this._poly.newLatLngIntersects(this._poly.getLatLngs()[0], !0); return !this.options.allowIntersection && a || !this._shapeIsValid() ? void this._showErrorTooltip() : (this._fireCreatedEvent(), this.disable(), void(this.options.repeatMode && this.enable())) }, _shapeIsValid: function() { return !0 }, _onZoomEnd: function() { this._updateGuide() }, _onMouseMove: function(a) { var b = a.layerPoint,
                c = a.latlng;
            this._currentLatLng = c, this._updateTooltip(c), this._updateGuide(b), this._mouseMarker.setLatLng(c), L.DomEvent.preventDefault(a.originalEvent) }, _vertexChanged: function(a, b) { this._updateFinishHandler(), this._updateRunningMeasure(a, b), this._clearGuides(), this._updateTooltip() }, _onMouseDown: function(a) { var b = a.originalEvent;
            this._mouseDownOrigin = L.point(b.clientX, b.clientY) }, _onMouseUp: function(b) { if (this._mouseDownOrigin) { var c = L.point(b.originalEvent.clientX, b.originalEvent.clientY).distanceTo(this._mouseDownOrigin);
                Math.abs(c) < 9 * (a.devicePixelRatio || 1) && this.addVertex(b.latlng) } this._mouseDownOrigin = null }, _updateFinishHandler: function() { var a = this._markers.length;
            a > 1 && this._markers[a - 1].on("click", this._finishShape, this), a > 2 && this._markers[a - 2].off("click", this._finishShape, this) }, _createMarker: function(a) { var b = new L.Marker(a, { icon: this.options.icon, zIndexOffset: 2 * this.options.zIndexOffset }); return this._markerGroup.addLayer(b), b }, _updateGuide: function(a) { var b = this._markers.length;
            b > 0 && (a = a || this._map.latLngToLayerPoint(this._currentLatLng), this._clearGuides(), this._drawGuide(this._map.latLngToLayerPoint(this._markers[b - 1].getLatLng()), a)) }, _updateTooltip: function(a) { var b = this._getTooltipText();
            a && this._tooltip.updatePosition(a), this._errorShown || this._tooltip.updateContent(b) }, _drawGuide: function(a, b) { var c, d, e, f = Math.floor(Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2))),
                g = this.options.guidelineDistance,
                h = this.options.maxGuideLineLength,
                i = f > h ? f - h : g; for (this._guidesContainer || (this._guidesContainer = L.DomUtil.create("div", "leaflet-draw-guides", this._overlayPane)); i < f; i += this.options.guidelineDistance) c = i / f, d = { x: Math.floor(a.x * (1 - c) + c * b.x), y: Math.floor(a.y * (1 - c) + c * b.y) }, e = L.DomUtil.create("div", "leaflet-draw-guide-dash", this._guidesContainer), e.style.backgroundColor = this._errorShown ? this.options.drawError.color : this.options.shapeOptions.color, L.DomUtil.setPosition(e, d) }, _updateGuideColor: function(a) { if (this._guidesContainer)
                for (var b = 0, c = this._guidesContainer.childNodes.length; b < c; b++) this._guidesContainer.childNodes[b].style.backgroundColor = a }, _clearGuides: function() { if (this._guidesContainer)
                for (; this._guidesContainer.firstChild;) this._guidesContainer.removeChild(this._guidesContainer.firstChild) }, _getTooltipText: function() { var a, b, c = this.options.showLength; return 0 === this._markers.length ? a = { text: L.drawLocal.draw.handlers.polyline.tooltip.start } : (b = c ? this._getMeasurementString() : "", a = 1 === this._markers.length ? { text: L.drawLocal.draw.handlers.polyline.tooltip.cont, subtext: b } : { text: L.drawLocal.draw.handlers.polyline.tooltip.end, subtext: b }), a }, _updateRunningMeasure: function(a, b) { var c, d, e = this._markers.length;
            1 === this._markers.length ? this._measurementRunningTotal = 0 : (c = e - (b ? 2 : 1), d = a.distanceTo(this._markers[c].getLatLng()), this._measurementRunningTotal += d * (b ? 1 : -1)) }, _getMeasurementString: function() { var a, b = this._currentLatLng,
                c = this._markers[this._markers.length - 1].getLatLng(); return a = this._measurementRunningTotal + b.distanceTo(c), L.GeometryUtil.readableDistance(a, this.options.metric) }, _showErrorTooltip: function() { this._errorShown = !0, this._tooltip.showAsError().updateContent({ text: this.options.drawError.message }), this._updateGuideColor(this.options.drawError.color), this._poly.setStyle({ color: this.options.drawError.color }), this._clearHideErrorTimeout(), this._hideErrorTimeout = setTimeout(L.Util.bind(this._hideErrorTooltip, this), this.options.drawError.timeout) }, _hideErrorTooltip: function() { this._errorShown = !1, this._clearHideErrorTimeout(), this._tooltip.removeError().updateContent(this._getTooltipText()), this._updateGuideColor(this.options.shapeOptions.color), this._poly.setStyle({ color: this.options.shapeOptions.color }) }, _clearHideErrorTimeout: function() { this._hideErrorTimeout && (clearTimeout(this._hideErrorTimeout), this._hideErrorTimeout = null) }, _cleanUpShape: function() { this._markers.length > 1 && this._markers[this._markers.length - 1].off("click", this._finishShape, this) }, _fireCreatedEvent: function() { var a = new this.Poly(this._poly.getLatLngs(), this.options.shapeOptions);
            L.Draw.Feature.prototype._fireCreatedEvent.call(this, a) } }), L.Draw.Polygon = L.Draw.Polyline.extend({ statics: { TYPE: "polygon" }, Poly: L.Polygon, options: { showArea: !1, shapeOptions: { stroke: !0, color: "#f06eaa", weight: 4, opacity: .5, fill: !0, fillColor: null, fillOpacity: .2, clickable: !0 } }, initialize: function(a, b) { L.Draw.Polyline.prototype.initialize.call(this, a, b), this.type = L.Draw.Polygon.TYPE }, _updateFinishHandler: function() { var a = this._markers.length;
            1 === a && this._markers[0].on("click", this._finishShape, this), a > 2 && (this._markers[a - 1].on("dblclick", this._finishShape, this), a > 3 && this._markers[a - 2].off("dblclick", this._finishShape, this)) }, _getTooltipText: function() { var a, b; return 0 === this._markers.length ? a = L.drawLocal.draw.handlers.polygon.tooltip.start : this._markers.length < 3 ? a = L.drawLocal.draw.handlers.polygon.tooltip.cont : (a = L.drawLocal.draw.handlers.polygon.tooltip.end, b = this._getMeasurementString()), { text: a, subtext: b } }, _getMeasurementString: function() { var a = this._area; return a ? L.GeometryUtil.readableArea(a, this.options.metric) : null }, _shapeIsValid: function() { return this._markers.length >= 3 }, _vertexChanged: function(a, b) { var c;!this.options.allowIntersection && this.options.showArea && (c = this._poly.getLatLngs(), this._area = L.GeometryUtil.geodesicArea(c)), L.Draw.Polyline.prototype._vertexChanged.call(this, a, b) }, _cleanUpShape: function() { var a = this._markers.length;
            a > 0 && (this._markers[0].off("click", this._finishShape, this), a > 2 && this._markers[a - 1].off("dblclick", this._finishShape, this)) } }), L.SimpleShape = {}, L.Draw.SimpleShape = L.Draw.Feature.extend({ options: { repeatMode: !1 }, initialize: function(a, b) { this._endLabelText = L.drawLocal.draw.handlers.simpleshape.tooltip.end, L.Draw.Feature.prototype.initialize.call(this, a, b) }, addHooks: function() { L.Draw.Feature.prototype.addHooks.call(this), this._map && (this._mapDraggable = this._map.dragging.enabled(), this._mapDraggable && this._map.dragging.disable(), this._container.style.cursor = "crosshair", this._tooltip.updateContent({ text: this._initialLabelText }), this._map.on("mousedown", this._onMouseDown, this).on("mousemove", this._onMouseMove, this)) }, removeHooks: function() { L.Draw.Feature.prototype.removeHooks.call(this), this._map && (this._mapDraggable && this._map.dragging.enable(), this._container.style.cursor = "", this._map.off("mousedown", this._onMouseDown, this).off("mousemove", this._onMouseMove, this), L.DomEvent.off(b, "mouseup", this._onMouseUp, this), this._shape && (this._map.removeLayer(this._shape), delete this._shape)), this._isDrawing = !1 }, _getTooltipText: function() { return { text: this._endLabelText } }, _onMouseDown: function(a) { this._isDrawing = !0, this._startLatLng = a.latlng, L.DomEvent.on(b, "mouseup", this._onMouseUp, this).preventDefault(a.originalEvent) }, _onMouseMove: function(a) { var b = a.latlng;
            this._tooltip.updatePosition(b), this._isDrawing && (this._tooltip.updateContent(this._getTooltipText()), this._drawShape(b)) }, _onMouseUp: function() { this._shape && this._fireCreatedEvent(), this.disable(), this.options.repeatMode && this.enable() } }), L.Draw.Rectangle = L.Draw.SimpleShape.extend({ statics: { TYPE: "rectangle" }, options: { shapeOptions: { stroke: !0, color: "#f06eaa", weight: 4, opacity: .5, fill: !0, fillColor: null, fillOpacity: .2, clickable: !0 }, metric: !0 }, initialize: function(a, b) { this.type = L.Draw.Rectangle.TYPE, this._initialLabelText = L.drawLocal.draw.handlers.rectangle.tooltip.start, L.Draw.SimpleShape.prototype.initialize.call(this, a, b) }, _drawShape: function(a) { this._shape ? this._shape.setBounds(new L.LatLngBounds(this._startLatLng, a)) : (this._shape = new L.Rectangle(new L.LatLngBounds(this._startLatLng, a), this.options.shapeOptions), this._map.addLayer(this._shape)) }, _fireCreatedEvent: function() { var a = new L.Rectangle(this._shape.getBounds(), this.options.shapeOptions);
            L.Draw.SimpleShape.prototype._fireCreatedEvent.call(this, a) }, _getTooltipText: function() { var a, b, c, d = L.Draw.SimpleShape.prototype._getTooltipText.call(this),
                e = this._shape; return e && (a = this._shape.getLatLngs(), b = L.GeometryUtil.geodesicArea(a), c = L.GeometryUtil.readableArea(b, this.options.metric)), { text: d.text, subtext: c } } }), L.Draw.Circle = L.Draw.SimpleShape.extend({ statics: { TYPE: "circle" }, options: { shapeOptions: { stroke: !0, color: "#f06eaa", weight: 4, opacity: .5, fill: !0, fillColor: null, fillOpacity: .2, clickable: !0 }, showRadius: !0, metric: !0 }, initialize: function(a, b) { this.type = L.Draw.Circle.TYPE, this._initialLabelText = L.drawLocal.draw.handlers.circle.tooltip.start, L.Draw.SimpleShape.prototype.initialize.call(this, a, b) }, _drawShape: function(a) { this._shape ? this._shape.setRadius(this._startLatLng.distanceTo(a)) : (this._shape = new L.Circle(this._startLatLng, this._startLatLng.distanceTo(a), this.options.shapeOptions), this._map.addLayer(this._shape)) }, _fireCreatedEvent: function() { var a = new L.Circle(this._startLatLng, this._shape.getRadius(), this.options.shapeOptions);
            L.Draw.SimpleShape.prototype._fireCreatedEvent.call(this, a) }, _onMouseMove: function(a) { var b, c = a.latlng,
                d = this.options.showRadius,
                e = this.options.metric;
            this._tooltip.updatePosition(c), this._isDrawing && (this._drawShape(c), b = this._shape.getRadius().toFixed(1), this._tooltip.updateContent({ text: this._endLabelText, subtext: d ? L.drawLocal.draw.handlers.circle.radius + ": " + L.GeometryUtil.readableDistance(b, e) : "" })) } }), L.Draw.Marker = L.Draw.Feature.extend({ statics: { TYPE: "marker" }, options: { icon: new L.Icon.Default, repeatMode: !1, zIndexOffset: 2e3 }, initialize: function(a, b) { this.type = L.Draw.Marker.TYPE, L.Draw.Feature.prototype.initialize.call(this, a, b) }, addHooks: function() { L.Draw.Feature.prototype.addHooks.call(this), this._map && (this._tooltip.updateContent({ text: L.drawLocal.draw.handlers.marker.tooltip.start }), this._mouseMarker || (this._mouseMarker = L.marker(this._map.getCenter(), { icon: L.divIcon({ className: "leaflet-mouse-marker", iconAnchor: [20, 20], iconSize: [40, 40] }), opacity: 0, zIndexOffset: this.options.zIndexOffset })), this._mouseMarker.on("click", this._onClick, this).addTo(this._map), this._map.on("mousemove", this._onMouseMove, this)) }, removeHooks: function() { L.Draw.Feature.prototype.removeHooks.call(this), this._map && (this._marker && (this._marker.off("click", this._onClick, this), this._map.off("click", this._onClick, this).removeLayer(this._marker), delete this._marker), this._mouseMarker.off("click", this._onClick, this), this._map.removeLayer(this._mouseMarker), delete this._mouseMarker, this._map.off("mousemove", this._onMouseMove, this)) }, _onMouseMove: function(a) { var b = a.latlng;
            this._tooltip.updatePosition(b), this._mouseMarker.setLatLng(b), this._marker ? (b = this._mouseMarker.getLatLng(), this._marker.setLatLng(b)) : (this._marker = new L.Marker(b, { icon: this.options.icon, zIndexOffset: this.options.zIndexOffset }), this._marker.on("click", this._onClick, this), this._map.on("click", this._onClick, this).addLayer(this._marker)) }, _onClick: function() { this._fireCreatedEvent(), this.disable(), this.options.repeatMode && this.enable() }, _fireCreatedEvent: function() { var a = new L.Marker(this._marker.getLatLng(), { icon: this.options.icon });
            L.Draw.Feature.prototype._fireCreatedEvent.call(this, a) } }), L.Edit = L.Edit || {}, L.Edit.Marker = L.Handler.extend({ initialize: function(a, b) { this._marker = a, L.setOptions(this, b) }, addHooks: function() { var a = this._marker;
            a.dragging.enable(), a.on("dragend", this._onDragEnd, a), this._toggleMarkerHighlight() }, removeHooks: function() { var a = this._marker;
            a.dragging.disable(), a.off("dragend", this._onDragEnd, a), this._toggleMarkerHighlight() }, _onDragEnd: function(a) { var b = a.target;
            b.edited = !0 }, _toggleMarkerHighlight: function() { if (this._icon) { var a = this._icon;
                a.style.display = "none", L.DomUtil.hasClass(a, "leaflet-edit-marker-selected") ? (L.DomUtil.removeClass(a, "leaflet-edit-marker-selected"), this._offsetMarker(a, -4)) : (L.DomUtil.addClass(a, "leaflet-edit-marker-selected"), this._offsetMarker(a, 4)), a.style.display = "" } }, _offsetMarker: function(a, b) { var c = parseInt(a.style.marginTop, 10) - b,
                d = parseInt(a.style.marginLeft, 10) - b;
            a.style.marginTop = c + "px", a.style.marginLeft = d + "px" } }), L.Marker.addInitHook(function() { L.Edit.Marker && (this.editing = new L.Edit.Marker(this), this.options.editable && this.editing.enable()) }), L.Edit = L.Edit || {}, L.Edit.Poly = L.Handler.extend({ options: { icon: new L.DivIcon({ iconSize: new L.Point(8, 8), className: "leaflet-div-icon leaflet-editing-icon" }) }, initialize: function(a, b) { this._poly = a, L.setOptions(this, b) }, addHooks: function() { var a = this._poly;
            a instanceof L.Polygon || (a.options.editing.fill = !1), a.setStyle(a.options.editing), this._poly._map && (this._markerGroup || this._initMarkers(), this._poly._map.addLayer(this._markerGroup)) }, removeHooks: function() { var a = this._poly;
            a.setStyle(a.options.original), a._map && (a._map.removeLayer(this._markerGroup), delete this._markerGroup, delete this._markers) }, updateMarkers: function() { this._markerGroup.clearLayers(), this._initMarkers() }, _initMarkers: function() { this._markerGroup || (this._markerGroup = new L.LayerGroup), this._markers = []; var a, b, c, d, e = this._poly._latlngs; for (a = 0, c = e.length; a < c; a++) d = this._createMarker(e[a], a), d.on("click", this._onMarkerClick, this), this._markers.push(d); var f, g; for (a = 0, b = c - 1; a < c; b = a++)(0 !== a || L.Polygon && this._poly instanceof L.Polygon) && (f = this._markers[b], g = this._markers[a], this._createMiddleMarker(f, g), this._updatePrevNext(f, g)) }, _createMarker: function(a, b) { var c = new L.Marker(a, { draggable: !0, icon: this.options.icon }); return c._origLatLng = a, c._index = b, c.on("drag", this._onMarkerDrag, this), c.on("dragend", this._fireEdit, this), this._markerGroup.addLayer(c), c }, _removeMarker: function(a) { var b = a._index;
            this._markerGroup.removeLayer(a), this._markers.splice(b, 1), this._poly.spliceLatLngs(b, 1), this._updateIndexes(b, -1), a.off("drag", this._onMarkerDrag, this).off("dragend", this._fireEdit, this).off("click", this._onMarkerClick, this) }, _fireEdit: function() { this._poly.edited = !0, this._poly.fire("edit") }, _onMarkerDrag: function(a) { var b = a.target;
            L.extend(b._origLatLng, b._latlng), b._middleLeft && b._middleLeft.setLatLng(this._getMiddleLatLng(b._prev, b)), b._middleRight && b._middleRight.setLatLng(this._getMiddleLatLng(b, b._next)), this._poly.redraw() }, _onMarkerClick: function(a) { var b = L.Polygon && this._poly instanceof L.Polygon ? 4 : 3,
                c = a.target;
            this._poly._latlngs.length < b || (this._removeMarker(c), this._updatePrevNext(c._prev, c._next), c._middleLeft && this._markerGroup.removeLayer(c._middleLeft), c._middleRight && this._markerGroup.removeLayer(c._middleRight), c._prev && c._next ? this._createMiddleMarker(c._prev, c._next) : c._prev ? c._next || (c._prev._middleRight = null) : c._next._middleLeft = null, this._fireEdit()) }, _updateIndexes: function(a, b) { this._markerGroup.eachLayer(function(c) { c._index > a && (c._index += b) }) }, _createMiddleMarker: function(a, b) { var c, d, e, f = this._getMiddleLatLng(a, b),
                g = this._createMarker(f);
            g.setOpacity(.6), a._middleRight = b._middleLeft = g, d = function() { var d = b._index;
                g._index = d, g.off("click", c, this).on("click", this._onMarkerClick, this), f.lat = g.getLatLng().lat, f.lng = g.getLatLng().lng, this._poly.spliceLatLngs(d, 0, f), this._markers.splice(d, 0, g), g.setOpacity(1), this._updateIndexes(d, 1), b._index++, this._updatePrevNext(a, g), this._updatePrevNext(g, b), this._poly.fire("editstart") }, e = function() { g.off("dragstart", d, this), g.off("dragend", e, this), this._createMiddleMarker(a, g), this._createMiddleMarker(g, b) }, c = function() { d.call(this), e.call(this), this._fireEdit() }, g.on("click", c, this).on("dragstart", d, this).on("dragend", e, this), this._markerGroup.addLayer(g) }, _updatePrevNext: function(a, b) { a && (a._next = b), b && (b._prev = a) }, _getMiddleLatLng: function(a, b) { var c = this._poly._map,
                d = c.project(a.getLatLng()),
                e = c.project(b.getLatLng()); return c.unproject(d._add(e)._divideBy(2)) } }), L.Polyline.addInitHook(function() { this.editing || (L.Edit.Poly && (this.editing = new L.Edit.Poly(this), this.options.editable && this.editing.enable()), this.on("add", function() { this.editing && this.editing.enabled() && this.editing.addHooks() }), this.on("remove", function() { this.editing && this.editing.enabled() && this.editing.removeHooks() })) }), L.Edit = L.Edit || {}, L.Edit.SimpleShape = L.Handler.extend({
        options: {
            moveIcon: new L.DivIcon({ iconSize: new L.Point(8, 8), className: "leaflet-div-icon leaflet-editing-icon leaflet-edit-move" }),
            resizeIcon: new L.DivIcon({
                iconSize: new L.Point(8, 8),
                className: "leaflet-div-icon leaflet-editing-icon leaflet-edit-resize"
            })
        },
        initialize: function(a, b) { this._shape = a, L.Util.setOptions(this, b) },
        addHooks: function() { var a = this._shape;
            a.setStyle(a.options.editing), a._map && (this._map = a._map, this._markerGroup || this._initMarkers(), this._map.addLayer(this._markerGroup)) },
        removeHooks: function() { var a = this._shape; if (a.setStyle(a.options.original), a._map) { this._unbindMarker(this._moveMarker); for (var b = 0, c = this._resizeMarkers.length; b < c; b++) this._unbindMarker(this._resizeMarkers[b]);
                this._resizeMarkers = null, this._map.removeLayer(this._markerGroup), delete this._markerGroup } this._map = null },
        updateMarkers: function() { this._markerGroup.clearLayers(), this._initMarkers() },
        _initMarkers: function() { this._markerGroup || (this._markerGroup = new L.LayerGroup), this._createMoveMarker(), this._createResizeMarker() },
        _createMoveMarker: function() {},
        _createResizeMarker: function() {},
        _createMarker: function(a, b) { var c = new L.Marker(a, { draggable: !0, icon: b, zIndexOffset: 10 }); return this._bindMarker(c), this._markerGroup.addLayer(c), c },
        _bindMarker: function(a) { a.on("dragstart", this._onMarkerDragStart, this).on("drag", this._onMarkerDrag, this).on("dragend", this._onMarkerDragEnd, this) },
        _unbindMarker: function(a) { a.off("dragstart", this._onMarkerDragStart, this).off("drag", this._onMarkerDrag, this).off("dragend", this._onMarkerDragEnd, this) },
        _onMarkerDragStart: function(a) { var b = a.target;
            b.setOpacity(0), this._shape.fire("editstart") },
        _fireEdit: function() { this._shape.edited = !0, this._shape.fire("edit") },
        _onMarkerDrag: function(a) { var b = a.target,
                c = b.getLatLng();
            b === this._moveMarker ? this._move(c) : this._resize(c), this._shape.redraw() },
        _onMarkerDragEnd: function(a) { var b = a.target;
            b.setOpacity(1), this._fireEdit() },
        _move: function() {},
        _resize: function() {}
    }), L.Edit = L.Edit || {}, L.Edit.Rectangle = L.Edit.SimpleShape.extend({ _createMoveMarker: function() { var a = this._shape.getBounds(),
                b = a.getCenter();
            this._moveMarker = this._createMarker(b, this.options.moveIcon) }, _createResizeMarker: function() { var a = this._getCorners();
            this._resizeMarkers = []; for (var b = 0, c = a.length; b < c; b++) this._resizeMarkers.push(this._createMarker(a[b], this.options.resizeIcon)), this._resizeMarkers[b]._cornerIndex = b }, _onMarkerDragStart: function(a) { L.Edit.SimpleShape.prototype._onMarkerDragStart.call(this, a); var b = this._getCorners(),
                c = a.target,
                d = c._cornerIndex;
            this._oppositeCorner = b[(d + 2) % 4], this._toggleCornerMarkers(0, d) }, _onMarkerDragEnd: function(a) { var b, c, d = a.target;
            d === this._moveMarker && (b = this._shape.getBounds(), c = b.getCenter(), d.setLatLng(c)), this._toggleCornerMarkers(1), this._repositionCornerMarkers(), L.Edit.SimpleShape.prototype._onMarkerDragEnd.call(this, a) }, _move: function(a) { for (var b, c = this._shape.getLatLngs(), d = this._shape.getBounds(), e = d.getCenter(), f = [], g = 0, h = c.length; g < h; g++) b = [c[g].lat - e.lat, c[g].lng - e.lng], f.push([a.lat + b[0], a.lng + b[1]]);
            this._shape.setLatLngs(f), this._repositionCornerMarkers() }, _resize: function(a) { var b;
            this._shape.setBounds(L.latLngBounds(a, this._oppositeCorner)), b = this._shape.getBounds(), this._moveMarker.setLatLng(b.getCenter()) }, _getCorners: function() { var a = this._shape.getBounds(),
                b = a.getNorthWest(),
                c = a.getNorthEast(),
                d = a.getSouthEast(),
                e = a.getSouthWest(); return [b, c, d, e] }, _toggleCornerMarkers: function(a) { for (var b = 0, c = this._resizeMarkers.length; b < c; b++) this._resizeMarkers[b].setOpacity(a) }, _repositionCornerMarkers: function() { for (var a = this._getCorners(), b = 0, c = this._resizeMarkers.length; b < c; b++) this._resizeMarkers[b].setLatLng(a[b]) } }), L.Rectangle.addInitHook(function() { L.Edit.Rectangle && (this.editing = new L.Edit.Rectangle(this), this.options.editable && this.editing.enable()) }), L.Edit = L.Edit || {}, L.Edit.Circle = L.Edit.SimpleShape.extend({ _createMoveMarker: function() { var a = this._shape.getLatLng();
            this._moveMarker = this._createMarker(a, this.options.moveIcon) }, _createResizeMarker: function() { var a = this._shape.getLatLng(),
                b = this._getResizeMarkerPoint(a);
            this._resizeMarkers = [], this._resizeMarkers.push(this._createMarker(b, this.options.resizeIcon)) }, _getResizeMarkerPoint: function(a) { var b = this._shape._radius * Math.cos(Math.PI / 4),
                c = this._map.project(a); return this._map.unproject([c.x + b, c.y - b]) }, _move: function(a) { var b = this._getResizeMarkerPoint(a);
            this._resizeMarkers[0].setLatLng(b), this._shape.setLatLng(a) }, _resize: function(a) { var b = this._moveMarker.getLatLng(),
                c = b.distanceTo(a);
            this._shape.setRadius(c) } }), L.Circle.addInitHook(function() { L.Edit.Circle && (this.editing = new L.Edit.Circle(this), this.options.editable && this.editing.enable()), this.on("add", function() { this.editing && this.editing.enabled() && this.editing.addHooks() }), this.on("remove", function() { this.editing && this.editing.enabled() && this.editing.removeHooks() }) }), L.LatLngUtil = { cloneLatLngs: function(a) { for (var b = [], c = 0, d = a.length; c < d; c++) b.push(this.cloneLatLng(a[c])); return b }, cloneLatLng: function(a) { return L.latLng(a.lat, a.lng) } }, L.GeometryUtil = L.extend(L.GeometryUtil || {}, { geodesicArea: function(a) { var b, c, d = a.length,
                e = 0,
                f = L.LatLng.DEG_TO_RAD; if (d > 2) { for (var g = 0; g < d; g++) b = a[g], c = a[(g + 1) % d], e += (c.lng - b.lng) * f * (2 + Math.sin(b.lat * f) + Math.sin(c.lat * f));
                e = 6378137 * e * 6378137 / 2 } return Math.abs(e) }, readableArea: function(a, b) { var c; return b ? c = a >= 1e4 ? (1e-4 * a).toFixed(2) + " ha" : a.toFixed(2) + " m&sup2;" : (a /= .836127, c = a >= 3097600 ? (a / 3097600).toFixed(2) + " mi&sup2;" : a >= 4840 ? (a / 4840).toFixed(2) + " acres" : Math.ceil(a) + " yd&sup2;"), c }, readableDistance: function(a, b) { var c; return b ? c = a > 1e3 ? (a / 1e3).toFixed(2) + " km" : Math.ceil(a) + " m" : (a *= 1.09361, c = a > 1760 ? (a / 1760).toFixed(2) + " miles" : Math.ceil(a) + " yd"), c } }), L.Util.extend(L.LineUtil, { segmentsIntersect: function(a, b, c, d) { return this._checkCounterclockwise(a, c, d) !== this._checkCounterclockwise(b, c, d) && this._checkCounterclockwise(a, b, c) !== this._checkCounterclockwise(a, b, d) }, _checkCounterclockwise: function(a, b, c) { return (c.y - a.y) * (b.x - a.x) > (b.y - a.y) * (c.x - a.x) } }), L.Polyline.include({ intersects: function() { var a, b, c, d = this._originalPoints,
                e = d ? d.length : 0; if (this._tooFewPointsForIntersection()) return !1; for (a = e - 1; a >= 3; a--)
                if (b = d[a - 1], c = d[a], this._lineSegmentsIntersectsRange(b, c, a - 2)) return !0; return !1 }, newLatLngIntersects: function(a, b) { return !!this._map && this.newPointIntersects(this._map.latLngToLayerPoint(a), b) }, newPointIntersects: function(a, b) { var c = this._originalPoints,
                d = c ? c.length : 0,
                e = c ? c[d - 1] : null,
                f = d - 2; return !this._tooFewPointsForIntersection(1) && this._lineSegmentsIntersectsRange(e, a, f, b ? 1 : 0) }, _tooFewPointsForIntersection: function(a) { var b = this._originalPoints,
                c = b ? b.length : 0; return c += a || 0, !this._originalPoints || c <= 3 }, _lineSegmentsIntersectsRange: function(a, b, c, d) { var e, f, g = this._originalPoints;
            d = d || 0; for (var h = c; h > d; h--)
                if (e = g[h - 1], f = g[h], L.LineUtil.segmentsIntersect(a, b, e, f)) return !0; return !1 } }), L.Polygon.include({ intersects: function() { var a, b, c, d, e, f = this._originalPoints; return !this._tooFewPointsForIntersection() && (!!(a = L.Polyline.prototype.intersects.call(this)) || (b = f.length, c = f[0], d = f[b - 1], e = b - 2, this._lineSegmentsIntersectsRange(d, c, e, 1))) } }), L.Control.Draw = L.Control.extend({ options: { position: "bottomleft", draw: {}, edit: !1 }, initialize: function(a) { if (L.version < "0.7") throw new Error("Leaflet.draw 0.2.3+ requires Leaflet 0.7.0+. Download latest from https://github.com/Leaflet/Leaflet/");
            L.Control.prototype.initialize.call(this, a); var b;
            this._toolbars = {}, L.DrawToolbar && this.options.draw && (b = new L.DrawToolbar(this.options.draw), this._toolbars[L.DrawToolbar.TYPE] = b, this._toolbars[L.DrawToolbar.TYPE].on("enable", this._toolbarEnabled, this)), L.EditToolbar && this.options.edit && (b = new L.EditToolbar(this.options.edit), this._toolbars[L.EditToolbar.TYPE] = b, this._toolbars[L.EditToolbar.TYPE].on("enable", this._toolbarEnabled, this)) }, onAdd: function(a) { var b, c = L.DomUtil.create("div", "leaflet-draw"),
                d = !1,
                e = "leaflet-draw-toolbar-top"; for (var f in this._toolbars) this._toolbars.hasOwnProperty(f) && (b = this._toolbars[f].addToolbar(a), b && (d || (L.DomUtil.hasClass(b, e) || L.DomUtil.addClass(b.childNodes[0], e), d = !0), c.appendChild(b))); return c }, onRemove: function() { for (var a in this._toolbars) this._toolbars.hasOwnProperty(a) && this._toolbars[a].removeToolbar() }, setDrawingOptions: function(a) { for (var b in this._toolbars) this._toolbars[b] instanceof L.DrawToolbar && this._toolbars[b].setOptions(a) }, _toolbarEnabled: function(a) { var b = a.target; for (var c in this._toolbars) this._toolbars[c] !== b && this._toolbars[c].disable() } }), L.Map.mergeOptions({ drawControlTooltips: !0, drawControl: !1 }), L.Map.addInitHook(function() { this.options.drawControl && (this.drawControl = new L.Control.Draw, this.addControl(this.drawControl)) }), L.Toolbar = L.Class.extend({ includes: [L.Mixin.Events], initialize: function(a) { L.setOptions(this, a), this._modes = {}, this._actionButtons = [], this._activeMode = null }, enabled: function() { return null !== this._activeMode }, disable: function() { this.enabled() && this._activeMode.handler.disable() }, addToolbar: function(a) { var b, c = L.DomUtil.create("div", "leaflet-draw-section"),
                d = 0,
                e = this._toolbarClass || "",
                f = this.getModeHandlers(a); for (this._toolbarContainer = L.DomUtil.create("div", "leaflet-draw-toolbar leaflet-bar"), this._map = a, b = 0; b < f.length; b++) f[b].enabled && this._initModeHandler(f[b].handler, this._toolbarContainer, d++, e, f[b].title); if (d) return this._lastButtonIndex = --d, this._actionsContainer = L.DomUtil.create("ul", "leaflet-draw-actions"), c.appendChild(this._toolbarContainer), c.appendChild(this._actionsContainer), c }, removeToolbar: function() { for (var a in this._modes) this._modes.hasOwnProperty(a) && (this._disposeButton(this._modes[a].button, this._modes[a].handler.enable, this._modes[a].handler), this._modes[a].handler.disable(), this._modes[a].handler.off("enabled", this._handlerActivated, this).off("disabled", this._handlerDeactivated, this));
            this._modes = {}; for (var b = 0, c = this._actionButtons.length; b < c; b++) this._disposeButton(this._actionButtons[b].button, this._actionButtons[b].callback, this);
            this._actionButtons = [], this._actionsContainer = null }, _initModeHandler: function(a, b, c, d, e) { var f = a.type;
            this._modes[f] = {}, this._modes[f].handler = a, this._modes[f].button = this._createButton({ title: e, className: d + "-" + f, container: b, callback: this._modes[f].handler.enable, context: this._modes[f].handler }), this._modes[f].buttonIndex = c, this._modes[f].handler.on("enabled", this._handlerActivated, this).on("disabled", this._handlerDeactivated, this) }, _createButton: function(a) { var b = L.DomUtil.create("a", a.className || "", a.container); return b.href = "#", a.text && (b.innerHTML = a.text), a.title && (b.title = a.title), L.DomEvent.on(b, "click", L.DomEvent.stopPropagation).on(b, "mousedown", L.DomEvent.stopPropagation).on(b, "dblclick", L.DomEvent.stopPropagation).on(b, "click", L.DomEvent.preventDefault).on(b, "click", a.callback, a.context), b }, _disposeButton: function(a, b) { L.DomEvent.off(a, "click", L.DomEvent.stopPropagation).off(a, "mousedown", L.DomEvent.stopPropagation).off(a, "dblclick", L.DomEvent.stopPropagation).off(a, "click", L.DomEvent.preventDefault).off(a, "click", b) }, _handlerActivated: function(a) { this.disable(), this._activeMode = this._modes[a.handler], L.DomUtil.addClass(this._activeMode.button, "leaflet-draw-toolbar-button-enabled"), this._showActionsToolbar(), this.fire("enable") }, _handlerDeactivated: function() { this._hideActionsToolbar(), L.DomUtil.removeClass(this._activeMode.button, "leaflet-draw-toolbar-button-enabled"), this._activeMode = null, this.fire("disable") }, _createActions: function(a) { var b, c, d, e, f = this._actionsContainer,
                g = this.getActions(a),
                h = g.length; for (c = 0, d = this._actionButtons.length; c < d; c++) this._disposeButton(this._actionButtons[c].button, this._actionButtons[c].callback); for (this._actionButtons = []; f.firstChild;) f.removeChild(f.firstChild); for (var i = 0; i < h; i++) "enabled" in g[i] && !g[i].enabled || (b = L.DomUtil.create("li", "", f), e = this._createButton({ title: g[i].title, text: g[i].text, container: b, callback: g[i].callback, context: g[i].context }), this._actionButtons.push({ button: e, callback: g[i].callback })) }, _showActionsToolbar: function() { var a = this._activeMode.buttonIndex,
                b = this._lastButtonIndex,
                c = this._activeMode.button.offsetTop - 1;
            this._createActions(this._activeMode.handler), this._actionsContainer.style.top = c + "px", 0 === a && (L.DomUtil.addClass(this._toolbarContainer, "leaflet-draw-toolbar-notop"), L.DomUtil.addClass(this._actionsContainer, "leaflet-draw-actions-top")), a === b && (L.DomUtil.addClass(this._toolbarContainer, "leaflet-draw-toolbar-nobottom"), L.DomUtil.addClass(this._actionsContainer, "leaflet-draw-actions-bottom")), this._actionsContainer.style.display = "block" }, _hideActionsToolbar: function() { this._actionsContainer.style.display = "none", L.DomUtil.removeClass(this._toolbarContainer, "leaflet-draw-toolbar-notop"), L.DomUtil.removeClass(this._toolbarContainer, "leaflet-draw-toolbar-nobottom"), L.DomUtil.removeClass(this._actionsContainer, "leaflet-draw-actions-top"), L.DomUtil.removeClass(this._actionsContainer, "leaflet-draw-actions-bottom") } }), L.Tooltip = L.Class.extend({ initialize: function(a) { this._map = a, this._popupPane = a._panes.popupPane, this._container = a.options.drawControlTooltips ? L.DomUtil.create("div", "leaflet-draw-tooltip", this._popupPane) : null, this._singleLineLabel = !1 }, dispose: function() { this._container && (this._popupPane.removeChild(this._container), this._container = null) }, updateContent: function(a) { return this._container ? (a.subtext = a.subtext || "", 0 !== a.subtext.length || this._singleLineLabel ? a.subtext.length > 0 && this._singleLineLabel && (L.DomUtil.removeClass(this._container, "leaflet-draw-tooltip-single"), this._singleLineLabel = !1) : (L.DomUtil.addClass(this._container, "leaflet-draw-tooltip-single"), this._singleLineLabel = !0), this._container.innerHTML = (a.subtext.length > 0 ? '<span class="leaflet-draw-tooltip-subtext">' + a.subtext + "</span><br />" : "") + "<span>" + a.text + "</span>", this) : this }, updatePosition: function(a) { var b = this._map.latLngToLayerPoint(a),
                c = this._container; return this._container && (c.style.visibility = "inherit", L.DomUtil.setPosition(c, b)), this }, showAsError: function() { return this._container && L.DomUtil.addClass(this._container, "leaflet-error-draw-tooltip"), this }, removeError: function() { return this._container && L.DomUtil.removeClass(this._container, "leaflet-error-draw-tooltip"), this } }), L.DrawToolbar = L.Toolbar.extend({ statics: { TYPE: "draw" }, options: { polyline: {}, polygon: {}, rectangle: {}, circle: {}, marker: {} }, initialize: function(a) { for (var b in this.options) this.options.hasOwnProperty(b) && a[b] && (a[b] = L.extend({}, this.options[b], a[b]));
            this._toolbarClass = "leaflet-draw-draw", L.Toolbar.prototype.initialize.call(this, a) }, getModeHandlers: function(a) { return [{ enabled: this.options.polyline, handler: new L.Draw.Polyline(a, this.options.polyline), title: L.drawLocal.draw.toolbar.buttons.polyline }, { enabled: this.options.polygon, handler: new L.Draw.Polygon(a, this.options.polygon), title: L.drawLocal.draw.toolbar.buttons.polygon }, { enabled: this.options.rectangle, handler: new L.Draw.Rectangle(a, this.options.rectangle), title: L.drawLocal.draw.toolbar.buttons.rectangle }, { enabled: this.options.circle, handler: new L.Draw.Circle(a, this.options.circle), title: L.drawLocal.draw.toolbar.buttons.circle }, { enabled: this.options.marker, handler: new L.Draw.Marker(a, this.options.marker), title: L.drawLocal.draw.toolbar.buttons.marker }] }, getActions: function(a) { return [{ enabled: a.deleteLastVertex, title: L.drawLocal.draw.toolbar.undo.title, text: L.drawLocal.draw.toolbar.undo.text, callback: a.deleteLastVertex, context: a }, { title: L.drawLocal.draw.toolbar.actions.title, text: L.drawLocal.draw.toolbar.actions.text, callback: this.disable, context: this }] }, setOptions: function(a) { L.setOptions(this, a); for (var b in this._modes) this._modes.hasOwnProperty(b) && a.hasOwnProperty(b) && this._modes[b].handler.setOptions(a[b]) } }), L.EditToolbar = L.Toolbar.extend({ statics: { TYPE: "edit" }, options: { edit: { selectedPathOptions: { color: "#fe57a1", opacity: .6, dashArray: "10, 10", fill: !0, fillColor: "#fe57a1", fillOpacity: .1, maintainColor: !1 } }, remove: {}, featureGroup: null }, initialize: function(a) { a.edit && ("undefined" == typeof a.edit.selectedPathOptions && (a.edit.selectedPathOptions = this.options.edit.selectedPathOptions), a.edit.selectedPathOptions = L.extend({}, this.options.edit.selectedPathOptions, a.edit.selectedPathOptions)), a.remove && (a.remove = L.extend({}, this.options.remove, a.remove)), this._toolbarClass = "leaflet-draw-edit", L.Toolbar.prototype.initialize.call(this, a), this._selectedFeatureCount = 0 }, getModeHandlers: function(a) { var b = this.options.featureGroup; return [{ enabled: this.options.edit, handler: new L.EditToolbar.Edit(a, { featureGroup: b, selectedPathOptions: this.options.edit.selectedPathOptions }), title: L.drawLocal.edit.toolbar.buttons.edit }, { enabled: this.options.remove, handler: new L.EditToolbar.Delete(a, { featureGroup: b }), title: L.drawLocal.edit.toolbar.buttons.remove }] }, getActions: function() { return [{ title: L.drawLocal.edit.toolbar.actions.save.title, text: L.drawLocal.edit.toolbar.actions.save.text, callback: this._save, context: this }, { title: L.drawLocal.edit.toolbar.actions.cancel.title, text: L.drawLocal.edit.toolbar.actions.cancel.text, callback: this.disable, context: this }] }, addToolbar: function(a) { var b = L.Toolbar.prototype.addToolbar.call(this, a); return this._checkDisabled(), this.options.featureGroup.on("layeradd layerremove", this._checkDisabled, this), b }, removeToolbar: function() { this.options.featureGroup.off("layeradd layerremove", this._checkDisabled, this), L.Toolbar.prototype.removeToolbar.call(this) }, disable: function() { this.enabled() && (this._activeMode.handler.revertLayers(), L.Toolbar.prototype.disable.call(this)) }, _save: function() { this._activeMode.handler.save(), this._activeMode.handler.disable() }, _checkDisabled: function() { var a, b = this.options.featureGroup,
                c = 0 !== b.getLayers().length;
            this.options.edit && (a = this._modes[L.EditToolbar.Edit.TYPE].button, c ? L.DomUtil.removeClass(a, "leaflet-disabled") : L.DomUtil.addClass(a, "leaflet-disabled"), a.setAttribute("title", c ? L.drawLocal.edit.toolbar.buttons.edit : L.drawLocal.edit.toolbar.buttons.editDisabled)), this.options.remove && (a = this._modes[L.EditToolbar.Delete.TYPE].button, c ? L.DomUtil.removeClass(a, "leaflet-disabled") : L.DomUtil.addClass(a, "leaflet-disabled"), a.setAttribute("title", c ? L.drawLocal.edit.toolbar.buttons.remove : L.drawLocal.edit.toolbar.buttons.removeDisabled)) } }), L.EditToolbar.Edit = L.Handler.extend({ statics: { TYPE: "edit" }, includes: L.Mixin.Events, initialize: function(a, b) { if (L.Handler.prototype.initialize.call(this, a), L.setOptions(this, b), this._featureGroup = b.featureGroup, !(this._featureGroup instanceof L.FeatureGroup)) throw new Error("options.featureGroup must be a L.FeatureGroup");
            this._uneditedLayerProps = {}, this.type = L.EditToolbar.Edit.TYPE }, enable: function() {!this._enabled && this._hasAvailableLayers() && (this.fire("enabled", { handler: this.type }), this._map.fire("draw:editstart", { handler: this.type }), L.Handler.prototype.enable.call(this), this._featureGroup.on("layeradd", this._enableLayerEdit, this).on("layerremove", this._disableLayerEdit, this)) }, disable: function() { this._enabled && (this._featureGroup.off("layeradd", this._enableLayerEdit, this).off("layerremove", this._disableLayerEdit, this), L.Handler.prototype.disable.call(this), this._map.fire("draw:editstop", { handler: this.type }), this.fire("disabled", { handler: this.type })) }, addHooks: function() { var a = this._map;
            a && (a.getContainer().focus(), this._featureGroup.eachLayer(this._enableLayerEdit, this), this._tooltip = new L.Tooltip(this._map), this._tooltip.updateContent({ text: L.drawLocal.edit.handlers.edit.tooltip.text, subtext: L.drawLocal.edit.handlers.edit.tooltip.subtext }), this._map.on("mousemove", this._onMouseMove, this)) }, removeHooks: function() { this._map && (this._featureGroup.eachLayer(this._disableLayerEdit, this), this._uneditedLayerProps = {}, this._tooltip.dispose(), this._tooltip = null, this._map.off("mousemove", this._onMouseMove, this)) }, revertLayers: function() { this._featureGroup.eachLayer(function(a) { this._revertLayer(a) }, this) }, save: function() { var a = new L.LayerGroup;
            this._featureGroup.eachLayer(function(b) { b.edited && (a.addLayer(b), b.edited = !1) }), this._map.fire("draw:edited", { layers: a }) }, _backupLayer: function(a) { var b = L.Util.stamp(a);
            this._uneditedLayerProps[b] || (a instanceof L.Polyline || a instanceof L.Polygon || a instanceof L.Rectangle ? this._uneditedLayerProps[b] = { latlngs: L.LatLngUtil.cloneLatLngs(a.getLatLngs()) } : a instanceof L.Circle ? this._uneditedLayerProps[b] = { latlng: L.LatLngUtil.cloneLatLng(a.getLatLng()), radius: a.getRadius() } : a instanceof L.Marker && (this._uneditedLayerProps[b] = { latlng: L.LatLngUtil.cloneLatLng(a.getLatLng()) })) }, _revertLayer: function(a) { var b = L.Util.stamp(a);
            a.edited = !1, this._uneditedLayerProps.hasOwnProperty(b) && (a instanceof L.Polyline || a instanceof L.Polygon || a instanceof L.Rectangle ? a.setLatLngs(this._uneditedLayerProps[b].latlngs) : a instanceof L.Circle ? (a.setLatLng(this._uneditedLayerProps[b].latlng), a.setRadius(this._uneditedLayerProps[b].radius)) : a instanceof L.Marker && a.setLatLng(this._uneditedLayerProps[b].latlng), a.fire("revert-edited", { layer: a })) }, _enableLayerEdit: function(a) { var b, c = a.layer || a.target || a;
            this._backupLayer(c), this.options.selectedPathOptions && (b = L.Util.extend({}, this.options.selectedPathOptions), b.maintainColor && (b.color = c.options.color, b.fillColor = c.options.fillColor), c.options.original = L.extend({}, c.options), c.options.editing = b), c.editing.enable() }, _disableLayerEdit: function(a) { var b = a.layer || a.target || a;
            b.edited = !1, b.editing.disable(), delete b.options.editing, delete b.options.original }, _onMouseMove: function(a) { this._tooltip.updatePosition(a.latlng) }, _hasAvailableLayers: function() { return 0 !== this._featureGroup.getLayers().length } }), L.EditToolbar.Delete = L.Handler.extend({ statics: { TYPE: "remove" }, includes: L.Mixin.Events, initialize: function(a, b) { if (L.Handler.prototype.initialize.call(this, a), L.Util.setOptions(this, b), this._deletableLayers = this.options.featureGroup, !(this._deletableLayers instanceof L.FeatureGroup)) throw new Error("options.featureGroup must be a L.FeatureGroup");
            this.type = L.EditToolbar.Delete.TYPE }, enable: function() {!this._enabled && this._hasAvailableLayers() && (this.fire("enabled", { handler: this.type }), this._map.fire("draw:deletestart", { handler: this.type }), L.Handler.prototype.enable.call(this), this._deletableLayers.on("layeradd", this._enableLayerDelete, this).on("layerremove", this._disableLayerDelete, this)) }, disable: function() { this._enabled && (this._deletableLayers.off("layeradd", this._enableLayerDelete, this).off("layerremove", this._disableLayerDelete, this), L.Handler.prototype.disable.call(this), this._map.fire("draw:deletestop", { handler: this.type }), this.fire("disabled", { handler: this.type })) }, addHooks: function() { var a = this._map;
            a && (a.getContainer().focus(), this._deletableLayers.eachLayer(this._enableLayerDelete, this), this._deletedLayers = new L.LayerGroup, this._tooltip = new L.Tooltip(this._map), this._tooltip.updateContent({ text: L.drawLocal.edit.handlers.remove.tooltip.text }), this._map.on("mousemove", this._onMouseMove, this)) }, removeHooks: function() { this._map && (this._deletableLayers.eachLayer(this._disableLayerDelete, this), this._deletedLayers = null, this._tooltip.dispose(), this._tooltip = null, this._map.off("mousemove", this._onMouseMove, this)) }, revertLayers: function() { this._deletedLayers.eachLayer(function(a) { this._deletableLayers.addLayer(a), a.fire("revert-deleted", { layer: a }) }, this) }, save: function() { this._map.fire("draw:deleted", { layers: this._deletedLayers }) }, _enableLayerDelete: function(a) { var b = a.layer || a.target || a;
            b.on("click", this._removeLayer, this) }, _disableLayerDelete: function(a) { var b = a.layer || a.target || a;
            b.off("click", this._removeLayer, this), this._deletedLayers.removeLayer(b) }, _removeLayer: function(a) { var b = a.layer || a.target || a;
            this._deletableLayers.removeLayer(b), this._deletedLayers.addLayer(b), b.fire("deleted") }, _onMouseMove: function(a) { this._tooltip.updatePosition(a.latlng) }, _hasAvailableLayers: function() { return 0 !== this._deletableLayers.getLayers().length } })
}(window, document),
function(a) { L.Control.SearchByMap = L.Control.extend({ options: { position: "bottomleft", title: "Search within this map area", active: !1 }, initialize: function(a) { L.Util.setOptions(this, a) }, onAdd: function(a) { this._active = this.options.active, this._map._searchByMap = this._active; var b = "";
            this._container = L.DomUtil.create("div", "leaflet-control-search leaflet-bar leaflet-control" + b); var c = L.DomUtil.create("a", "leaflet-bar-part leaflet-bar-part-single", this._container);
            c.href = "#", c.title = this.options.title;
            L.DomUtil.create("span", "mapbox-icon mapbox-icon-search", c); return L.DomEvent.on(c, "click", L.DomEvent.stopPropagation).on(c, "click", L.DomEvent.preventDefault).on(c, "click", function() { this._map.fire("startsearchbymap", this) }, this).on(c, "dblclick", L.DomEvent.stopPropagation), this._active && this.start(), this._container }, toggleActive: function() { this._active ? this.start() : this.stop() }, start: function() { this._active = !0, this._map._searchByMap = !0, this._map.fire("startsearchbymap", this) }, stop: function() { this._active = !1, this._map._searchByMap = !1, this._map.fire("stopsearchbymap", this) } }) }(window),
function(a) {
    function b(a) { a.drawnItems.clearLayers(); var b = a.form.find("input[name=radius_object]");
        b.length && b.remove(); var c = a.form.find("input[name=SEARCH_polygon]");
        c.length && c.remove(); var d = a.form.find("input[name=SEARCH_viewport]");
        d.length && d.remove(), a.drawnItem = !1 }

    function c(a) { return a.replace(/\w\S*/g, function(a) { return a.charAt(0).toUpperCase() + a.substr(1).toLowerCase() }) }

    function d(a, b, c, d, f) { for (var g, h, i, j = a, k = [], l = 0; l < c; l++) g = 360 * l / c + d, h = e(j, g, b), i = L.latLng(h.lng, h.lat), k.push(i); return k }

    function e(a, b, c) { for (var d = L.Util, e = d.VincentyConstants, f = e.a, g = e.b, h = e.f, i = a.lng, j = a.lat, k = c, l = Math.PI, m = b * l / 180, n = Math.sin(m), o = Math.cos(m), p = (1 - h) * Math.tan(j * l / 180), q = 1 / Math.sqrt(1 + p * p), r = p * q, s = Math.atan2(p, o), t = q * n, u = 1 - t * t, v = u * (f * f - g * g) / (g * g), w = 1 + v / 16384 * (4096 + v * (-768 + v * (320 - 175 * v))), x = v / 1024 * (256 + v * (-128 + v * (74 - 47 * v))), y = k / (g * w), z = 2 * Math.PI; Math.abs(y - z) > 1e-12;) { var A = Math.cos(2 * s + y),
                B = Math.sin(y),
                C = Math.cos(y),
                D = x * B * (A + x / 4 * (C * (-1 + 2 * A * A) - x / 6 * A * (-3 + 4 * B * B) * (-3 + 4 * A * A)));
            z = y, y = k / (g * w) + D } var E = r * B - q * C * o,
            F = Math.atan2(r * C + q * B * o, (1 - h) * Math.sqrt(t * t + E * E)),
            G = Math.atan2(B * n, q * C - r * B * o),
            H = h / 16 * u * (4 + h * (4 - 3 * u)),
            I = G - (1 - H) * h * t * (y + H * B * (A + H * C * (-1 + 2 * A * A))),
            J = (Math.atan2(t, -E), i + 180 * I / l),
            K = 180 * F / l; return L.latLng(J, K) } ih.map = { imgBaseUrl: ih.staticurl("/images/gmap/"), criticalZoom: 12, defaultOptions: { zoom: 8, center: "37, -100", mousewheel_enabled: !0, map_type: null }, markerClusterOptions: { showCoverageOnHover: !1, maxClusterRadius: 50, chunkedLoading: !0, chunkInterval: 100, chunkDelay: 10, chunkProgress: function(a, b, c) {} }, polygonOptions: { color: "#ffffff", opacity: .75, weight: 0, fillColor: "#ffffff", fillOpacity: .15, click: !1 } };
    var f, g = !1;
    ih.map.labelIcon = function(a, b) { return L.divIcon({ popupAnchor: [0, -20], className: a, html: "<span class='ih-map-price-arrow'></span><span class='ih-map-price-label'>" + b + "</span>" }) }, ih.map.priceLabelIcon = function(a) { return ih.map.labelIcon("ih-map-price-label-icon", a) }, ih.map.youAreHereIcon = function() { return L.divIcon({ iconSize: [12, 12], iconAnchor: [6, 6], popupAnchor: [0, -6], className: "ih-map-icon-you-are-here", html: "<div class='ih-map-icon-you-are-here-ring ih-anim-pulsate infinite'></div><div class='ih-map-icon-you-are-here-circle'></div>" }) }, ih.map.makeLatLngFromCenterpoint = function(a) { a.indexOf("LatLng") != -1 && (a = a.replace("LatLng(", ""), a = a.replace(")", "")); var b = a.split(","); return new L.LatLng(parseFloat(b[0]), parseFloat(b[1])) }, ih.map.createPriceMarker = function(a, b) { var c = new L.Marker(b, { icon: ih.map.priceLabelIcon(a), riseOnHover: !0 }); return c }, ih.map.distanceBetween = function(a, b, c, d) { var e = [a, c],
            f = [b, d],
            g = 6378137,
            h = (e[1] - e[0]) * Math.PI / 180,
            i = (f[1] - f[0]) * Math.PI / 180,
            j = Math.sin(h / 2) * Math.sin(h / 2) + Math.cos(e[0] * Math.PI / 180) * Math.cos(e[1] * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2),
            k = 2 * Math.atan2(Math.sqrt(j), Math.sqrt(1 - j)),
            l = g * k; return Math.round(l) }, ih.map.createIndexFromPoint = function(a) { var b = new Number(a.lat),
            c = new Number(a.lng); return String(b.toFixed(4).toString() + c.toFixed(4).toString()) }, ih.map.addCommasToNumber = function(a) { a += "", x = a.split("."), x1 = x[0], x2 = x.length > 1 ? "." + x[1] : ""; for (var b = /(\d+)(\d{3})/; b.test(x1);) x1 = x1.replace(b, "$1,$2"); return x1 + x2 }, ih.map.hideCityInfo = function(a) { "undefined" != typeof a && "undefined" != typeof a.infoWindow && a.infoWindow.close() }, ih.map.processMapChange = function(b) { f = b.getCenter(), a("#zoom_level")[0].innerHTML = b.getZoom(), a("#ctr_coords")[0].innerHTML = b.getCenter(), a("#bounds_coords")[0].innerHTML = b.getBounds(), 0 == g && (a("#SEARCH_viewport").val(ih.map.mapBoundsToSearchParams(b.getBounds())), a("#SEARCH_centerpoint").val(b.getCenter()), a("#SEARCH_zoom").val(b.getZoom()), ih.map.refreshListingMarkers(b)) }, ih.map.translateMapType = function(a) { switch (a.toUpperCase()) {
            case "ROADMAP":
                return "roadmap";
            case "TERRAIN":
                return "terrain";
            case "HYBRID":
            case "SATELLITE":
                return "satellite";
            default:
                return "terrain" } }, ih.map.mapBoundsToSearchParams = function(a) { var b = Array(); return b[0] = [a.getSouthWest().lat, a.getSouthWest().lng], b[1] = [a.getNorthEast().lat, a.getNorthEast().lng], b }, ih.map.load = function(e, f) {
        window.gtag && gtag("event", "mapLoad", { event_category: "User", event_action: "Mapbox", event_label: "MapLoad" });
        var g = a("#" + e),
            h = { zoom: g.data("zoom") || 8, centerpoint: g.data("centerpoint") || "37, -100", scrollWheelZoom: g.data("mousewheel") || !1, maptype: g.data("maptype") || "Terrain", attributionControl: !0 };
        a.extend(h, f);
        var i = "pk.eyJ1IjoiaWhvdXNlZWxpdGUiLCJhIjoiVTVUY2VldyJ9.2rhVgyV1M47cEqg7doivCg",
            j = "?access_token=" + i,
            k = "https:" == location.protocol ? "https:" : "http:",
            l = { Roadmap: L.mapbox.tileLayer(k + "//api.mapbox.com/styles/v1/ihouseelite/cjl2e0ww98q1m2rpa9fznuayl" + j, { maxZoom: 17, tileSize: 256, accessToken: i }), Terrain: L.mapbox.tileLayer(k + "//api.mapbox.com/styles/v1/ihouseelite/cjl2oq7or080r2sl2jkh5f3oa" + j, { maxZoom: 17, tileSize: 256, accessToken: i }), Satellite: L.mapbox.tileLayer(k + "//api.mapbox.com/styles/v1/ihouseelite/cjl2oisrw6u262sqmzct3lzn3" + j, { tileSize: 256, accessToken: i }) };
        h.center = ih.map.strToLatLng(h.centerpoint), h.maptype = c(h.maptype), h.layers = l[h.maptype];
        var m = L.map(g.attr("id"), h),
            n = L.Control.extend({ options: { position: "bottomleft" }, onAdd: function(a) { return L.DomUtil.create("div", "map-message") }, setContent: function(a) { this.getContainer().innerHTML = a } });
        ih.map.CustomMessage = (new n).addTo(m), m.drawingEnabled = !1, m.drawControlVisible = !1, m.ihMapDrawUIVisible = !1, m.removeOutlineControlVisible = !1, m.resultsEnabled = !1, m.drawInProgress = !1, m.resubmitFormOnChange = !1, m.drawnItem = !1, m.drawnItems = new L.FeatureGroup, m.addLayer(m.drawnItems), m.allResultsLoaded = !1, L.control.layers(l).addTo(m);
        var o = L.control.locate({ position: "topleft", keepCurrentZoomLevel: !0, icon: "mapbox-icon mapbox-icon-locate", iconLoading: "mapbox-icon mapbox-icon-locate ih-anim-spin infinite", markerClass: L.marker, markerStyle: { icon: ih.map.youAreHereIcon() } });
        m.locateControl = o, void 0 !== navigator.permissions ? navigator.permissions.query({ name: "geolocation" }).then(function(a) { "granted" == a.state ? m.locateControl.addTo(m) : "prompt" == a.state ? m.locateControl.addTo(m) : "denied" == a.state }) : navigator.geolocation && m.locateControl.addTo(m), m.tileLayers = l, m.searchBoundsLayer = L.featureGroup(), m.addLayer(m.searchBoundsLayer), a(".leaflet-control-attribution a").attr("target", "leaflet_window");
        var p = { paddingTopLeft: [0, 30], paddingBottomLeft: [0, 30] };
        return m.fitBounds(m.getBounds(), p), m.on("resize", function(a) { var b = m.getZoom(),
                c = m.getCenter();
            m.invalidateSize(!1).setView(c, b) }), m.on("popupopen", function(b) { if ("" == b.popup._content) { var c = "<div class='listing-info-window loading'><div class='ih-icon-spinner4 ih-anim-spin infinite'></div></div>";
                b.popup.marker.setPopupContent(c); var d = a(".listing[data-mlsid=" + b.popup.marker.listing.mls_id + "][data-mlsno=" + b.popup.marker.listing.mls_no + "]"); if (d.length) { var e = ih.map.getPopupHTMLFromListingTile(d);
                    b.popup.marker.setPopupContent(e), a(b.popup.marker._icon).addClass("active") } else a.get(ih.url("/ListingSearch/details/"), { mls_id: b.popup.marker.listing.mls_id, mls_no: b.popup.marker.listing.mls_no, infowindow: !0 }).done(function(c) { d = a(c); var e = ih.map.getPopupHTMLFromListingTile(d);
                    b.popup.marker.setPopupContent(e), a(b.popup.marker._icon).addClass("active") }) } else { var f = a(b.popup._content),
                    g = !1;
                f.data("listingid") ? g = f.data("listingid") : f.data("mlsid") && f.data("mlsno") && (g = f.data("mlsid") + "_" + f.data("mlsno")), g && (ih.data.savedListings.indexOf(g) > -1 ? f.addClass("saved") : f.removeClass("saved"), a(b.popup.marker._icon).addClass("active")) } }), m.on("popupclose", function(b) {
            b.popup.marker && a(b.popup.marker._icon).removeClass("active")
        }), m.on("draw:drawstart", function(a) { m.drawInProgress = !0, m.removeLayer(m.drawnItems) }), m.on("draw:drawstop", function(a) { m.addLayer(m.drawnItems), m.drawnItem || !m.ihMapDrawUIVisible && m.drawingEnabled && (m.addControl(ih.map.drawUI), m.ihMapDrawUIVisible = !0), m.drawControlVisible && (m.drawControlVisible = !1, m.removeControl(ih.map.drawControl)), m.drawInProgress = !1 }), m.on("draw:created", function(c) { console.log("DRAW CREATED TRIGGERED"), m.allResultsLoaded = !1, m.removeOutlineControlVisible || (m.addControl(ih.map.removeOutline), m.removeOutlineControlVisible = !0), b(m); var e = c.layerType; if (layer = c.layer, m.drawnItem = {}, m.drawnItem.type = e, m.drawnItem.layer = layer, "polygon" == e || "rectangle" == e) { var f = new L.Polygon([ih.map.negativeSpace, layer.getLatLngs()], ih.map.negativeShapeOptions);
                m.drawnItems.addLayer(f, ih.map.negativeSpaceOptions) } else { for (var g = layer.getLatLng(), h = layer.getRadius(), i = L.CRS.EPSG4326, j = d(g, h, 500, 0, i), f = [], k = 0; k < j.length; k++) { var l = [j[k].lat, j[k].lng];
                    f.push(l) } var n = new L.Polygon([ih.map.negativeSpace, f], ih.map.negativeShapeOptions);
                m.drawnItems.addLayer(n, ih.map.negativeShapeOptions) } if ("polygon" == e) { var o = (layer.getLatLngs().length, "("),
                    p = "",
                    q = layer.getLatLngs()[0];
                a.each(q, function(a, b) { o += b.lat + " ", o += b.lng + ", ", 0 == a && (p = b.lat + " " + b.lng) }), o += p + ")"; var r = m.form.find("input[name=SEARCH_polygon]");
                r.length || (r = a("<input name='SEARCH_polygon' type='hidden'>").appendTo(m.form)), r.val(o) } if ("circle" == e) { var s = { radius: layer.getRadius() / 1609.34, given_lat: layer.getLatLng().lat, given_lng: layer.getLatLng().lng },
                    t = m.form.find("input[name=radius_object]");
                t.length || (t = a("<input name='radius_object' type='hidden'>").appendTo(m.form)), t.val(JSON.stringify(s)) } m.drawInProgress = !1, currentZoom = m.getZoom(), currentCenterLat = m.getCenter().lat, currentCenterLng = m.getCenter().lng, m.fitBounds(layer.getBounds()), mapSearchBounds = m.getBounds(), m.searchBoundsLayer.clearLayers(), !m.resubmitFormOnChange || currentZoom != m.getZoom() || currentCenterLat == m.getCenter().lat && currentCenterLng == m.getCenter().lng || m.form.trigger("submit"), m.ihMapDrawUIVisible && (m.removeControl(ih.map.drawUI), m.ihMapDrawUIVisible = !1) }), m.on("draw:deleted", function(a) { var b = (a.layerType, a.layer);
            m.drawnItems.removeLayer(b) }), m.boundaryPolylines = [], m.negativeSpacePolygon = !1, m.enableDrawing = function() { if (m.drawingEnabled = !0, m.form && void 0 !== m.form.find("input[name=SEARCH_viewport]").val() && "" !== m.form.find("input[name=SEARCH_viewport]").val()) { var b = m.form.find("input[name=SEARCH_viewport]").val(),
                    c = b.split("(").join("").split(")").join("").split(","),
                    e = [];
                e.push(new L.latLng(c[0], c[1])), e.push(new L.latLng(c[2], c[3])), m.fitBounds(e), m.invalidateSize(!1) } if (m.form && void 0 !== m.form.find("input[name=SEARCH_polygon]").val() && "" !== m.form.find("input[name=SEARCH_polygon]").val()) { $polygon_string = m.form.find("input[name=SEARCH_polygon]").val(); var f = $polygon_string.replace("(", "").replace(")", "").split(","),
                    e = []; for (o = 0; o < f.length; o++) { var g = f[o].trim().split(" "),
                        h = new L.latLng(g[0], g[1]);
                    e.push(h) } m.drawnItem = {}, m.drawnItem.type = "polygon", m.drawnItem.layer = new L.Polygon(e, ih.map.shapeOptions); var i = new L.Polygon([ih.map.negativeSpace, m.drawnItem.layer.getLatLngs()], ih.map.negativeShapeOptions);
                m.drawnItems.addLayer(i, ih.map.negativeShapeOptions), m.addControl(ih.map.removeOutline), m.removeOutlineControlVisible = !0, void 0 != m.form.find("input[name=SEARCH_viewport]").val() && "" != m.form.find("input[name=SEARCH_viewport]").val() || (m.fitBounds(m.drawnItem.layer.getBounds()), m.invalidateSize(!1)) } else if (m.form && void 0 !== m.form.find("input[name=radius_object_initial]").val() && "" !== m.form.find("input[name=radius_object_initial]").val()) { circle_object = JSON.parse(m.form.find("input[name=radius_object_initial]").val()); for (var j = 1609.34 * circle_object.radius, k = L.latLng(circle_object.given_lat, circle_object.given_lng), l = L.CRS.EPSG4326, n = d(k, j, 500, 0, l), i = [], o = 0; o < n.length; o++) { var p = [n[o].lat, n[o].lng];
                    i.push(p) } var q = new L.Polygon([ih.map.negativeSpace, i], ih.map.negativeShapeOptions);
                m.drawnItems.addLayer(q, ih.map.negativeShapeOptions), m.drawnItem = {}, m.drawnItem.type = "circle", m.drawnItem.layer = L.circle(k, j), m.addControl(ih.map.removeOutline), m.removeOutlineControlVisible = !0, void 0 != m.form.find("input[name=SEARCH_viewport]").val() && "" != m.form.find("input[name=SEARCH_viewport]").val() || (m.fitBounds(m.drawnItem.layer.getBounds()), m.invalidateSize(!1)); var r = m.form.find("input[name=radius_object]");
                r.length || (r = a("<input name='radius_object' type='hidden'>").appendTo(m.form)), r.val(JSON.stringify(circle_object)), m.form.find("input[name=radius_object_initial]").remove() } else m.ihMapDrawUIVisible || (m.addControl(ih.map.drawUI), m.ihMapDrawUIVisible = !0) }, m.disableDrawing = function() { m.drawingEnabled = !1, m.ihMapDrawUIVisible && (m.removeControl(ih.map.drawUI), m.ihMapDrawUIVisible = !1), m.removeOutlineControlVisible && (m.removeControl(ih.map.removeOutline), m.removeOutlineControlVisible = !1), m.drawControlVisible && (m.drawControlVisible = !1, m.removeControl(ih.map.drawControl)), b(m) }, m
    }, ih.map.changeMapType = function(a, b) { var d = c(a); for (var e in b.tileLayers) b.hasLayer(b.tileLayers[e]) && e !== d && b.removeLayer(b.tileLayers[e]);
        b.addLayer(b.tileLayers[d]) }, ih.map.getPopupHTMLFromListingTile = function(a) { var b = a.first().clone(); return b.find(".listing-open-house, .listing-photos-qty, .listing-button-map, .listing-button-view-details").remove(), b.removeClass("listing").addClass("listing-info-window"), b.find(".listing-photo-wrapper").removeClass("listing-photo-wrapper").addClass("listing-info-window-photo-wrapper"), b.find(".listing-offer").removeClass("listing-offer").addClass("listing-info-window-offer"), b.find(".listing-price").removeClass("listing-price").addClass("listing-info-window-price"), b.find(".listing-tag").remove(), b.find(".listing-name").removeClass("listing-name").addClass("listing-info-window-name"), b.find(".listing-basic-info").removeClass("listing-basic-info").addClass("listing-info-window-basic-info"), b.find(".listing-footer").removeClass("listing-footer").addClass("listing-info-window-footer"), b.find(".listing-courtesy-of").removeClass("listing-courtesy-of").addClass("listing-info-window-courtesy-of"), b.find(".listing-mls-number").removeClass("listing-mls-number").addClass("listing-info-window-mls-number"), b.find(".listing-mls-icon").removeClass("listing-mls-icon").addClass("listing-info-window-mls-icon"), b.find(".listing-buttons").removeClass("listing-buttons").addClass("listing-info-window-listing-buttons"), b[0] };
    var h = L.Control.extend({ options: { position: "bottomleft", title: "Draw a shape to filter results" }, onAdd: function(a) { var b = L.DomUtil.create("div", "leaflet-bar leaflet-control leaflet-draw-custom-edit"); return b.innerHTML = "<div class='leaflet-draw-edit-icon'>&nbsp;</div><span class='leaflet-control-label'>Draw Search</span>", b.onclick = function(b) { if (b.preventDefault(), a.drawControlVisible) a.drawControlVisible = !1, a.removeControl(ih.map.drawControl);
                else { a.removeOutlineControlVisible && (a.removeControl(removeOutline), a.removeOutlineControlVisible = !1), a.addControl(ih.map.drawControl), a.drawControlVisible = !0, a.ihMapDrawUIVisible && (a.removeControl(ih.map.drawUI), a.ihMapDrawUIVisible = !1); var c = document.createEvent("Event");
                    c.initEvent("click", !0, !0); var d = document.getElementsByClassName("leaflet-draw-draw-polygon");!d[0].dispatchEvent(c), a.removeOutlineControlVisible && a.addControl(ih.map.removeOutline) } }, L.DomEvent.disableClickPropagation(b), b } });
    ih.map.drawUI = new h, ih.map.shapeOptionsNoFill = { color: "#507070", opacity: .75, fillOpacity: .6, weight: 3 }, ih.map.negativeSpace = [new L.LatLng((-85), (-180)), new L.LatLng((-85), 180), new L.LatLng(85, 180), new L.LatLng(85, (-180)), new L.LatLng((-85), (-180))], ih.map.negativeShapeOptions = { color: "#507070", opacity: .75, fillOpacity: .6, weight: 3 }, ih.map.drawControl = new L.Control.Draw({ draw: { polyline: !1, marker: !1, circle: !1, rectangle: !1, polygon: { allowIntersection: !1, drawError: { color: "#e1e100", message: "<strong>Oops!<strong> You can't draw that!" }, shapeOptions: ih.map.shapeOptionsNoFill } } });
    var i = L.Control.extend({ options: { position: "bottomleft", title: "Remove outline and search within this map area" }, onAdd: function(a) { var c = L.DomUtil.create("div", "leaflet-bar leaflet-control leaflet-draw-custom-edit"); return c.innerHTML = "<span class='mapbox-icon mapbox-icon-clear'></span><span class='leaflet-control-label'>Clear Search</span>", c.onclick = function(c) { c.preventDefault(), b(a), a.removeControl(ih.map.removeOutline), a.removeOutlineControlVisible = !1, a.addControl(ih.map.drawUI), a.ihMapDrawUIVisible = !0, a.resultsEnabled && (mapSearchBounds = a.getBounds(), a.searchBoundsLayer.clearLayers(), a.drawnItem || L.rectangle(mapSearchBounds, ih.map.polygonOptions).addTo(a.searchBoundsLayer), a.resubmitFormOnChange && a.form.trigger("submit")) }, c } });
    ih.map.removeOutline = new i;
    ih.map.loadBoundaryInfo = function(b, c) { a.get(ih.url("/Boundary/get_city_boundary/"), { city_name: b }, function(b) { var d = [];
            a.each(b.boundary_info, function(a, b) { d[b.idx] = [], d[b.idx].state = b.state, d[b.idx].location = b.location, d[b.idx].type = b.polygon_type, d[b.idx].polygon = b.polygon }), ih.map.drawBoundary(d, c) }) }, ih.map.drawBoundary = function(a, b) { var c, d, e = null,
            f = []; if (b.searchBoundsLayer.clearLayers(), 0 != a.length) { for (var g = 0; g < a.length; g++) { f[g] = [], c = a[g].polygon.split(" "); for (var h = 0; h < c.length; h++) d = c[h].split(","), f[g][h] = new L.LatLng(d[0], d[1]);
                f[g].forEach(function(a) { if (0 != a.lat && 0 != a.lng) { var b = new L.LatLng(a.lat, a.lng);
                        e ? e.contains(b) || e.extend(b) : e = new L.LatLngBounds(b, b) } }) } var i = L.polygon(f, { color: "#ffffff", opacity: .5, weight: 4, fill: !1, click: !1 });
            b.searchBoundsLayer.addLayer(i); var j = L.polygon(f, ih.map.polygonOptions);
            b.searchBoundsLayer.addLayer(j) } }, ih.map.deleteBoundary = function(a) { a.searchBoundsLayer.clearLayers(), a.boundaryPolylines = [] }, ih.map.strToLatLng = function(a) { "string" != typeof a && console.error("coords argument must be a string!"); var b = a.split(","); return new L.LatLng(parseFloat(b[0]), parseFloat(b[1])) }, L.Util.VincentyConstants = { a: 6378137, b: 6356752.3142, f: 1 / 298.257223563 }
}(jQuery);
//# sourceMappingURL=maps.js.map
